<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chentianyuan.github.io</id>
    <title>City Corner</title>
    <updated>2020-11-04T03:38:41.618Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chentianyuan.github.io"/>
    <link rel="self" href="https://chentianyuan.github.io/atom.xml"/>
    <subtitle>脚踏实地 仰望星空</subtitle>
    <logo>https://chentianyuan.github.io/images/avatar.png</logo>
    <icon>https://chentianyuan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, City Corner</rights>
    <entry>
        <title type="html"><![CDATA[React简易源码构建]]></title>
        <id>https://chentianyuan.github.io/post/react-jian-yi-yuan-ma-gou-jian/</id>
        <link href="https://chentianyuan.github.io/post/react-jian-yi-yuan-ma-gou-jian/">
        </link>
        <updated>2020-11-02T02:03:05.000Z</updated>
        <summary type="html"><![CDATA[<p>一步一步进行react源码构建<br>
原文链接：<br>
<a href="https://pomb.us/build-your-own-react/">Build your own React</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>一步一步进行react源码构建<br>
原文链接：<br>
<a href="https://pomb.us/build-your-own-react/">Build your own React</a></p>
<!-- more -->
<h1 id="第一步观察jsx转化">第一步：观察jsx转化</h1>
<p>一个简单的React例子如下</p>
<pre><code class="language-javascript">const element = &lt;h1 title=&quot;foo&quot;&gt;Hello&lt;/h1&gt;
const container = document.getElementById(&quot;root&quot;)
ReactDOM.render(element, container)
</code></pre>
<p>jsx文件中的jsx语法会被@babel/preset-react插件所转译，模板会被转译成React.createElement包裹的对象形式</p>
<pre><code class="language-javascript">const element = React.createElement(&quot;h1&quot;, { title: &quot;foo&quot; }, &quot;Hello&quot;)
const container = document.getElementById(&quot;root&quot;)
ReactDOM.render(element, container)
</code></pre>
<p>然后React.createElement又会根据传入的对象形式，得到真正的React虚拟DOM</p>
<pre><code class="language-javascript">const element = {
    type: &quot;h1&quot;,
    props: {
        title: &quot;foo&quot;,
        children: &quot;Hello&quot;
    }
}
const container = document.getElementById(&quot;root&quot;)
ReactDOM.render(element, container)
</code></pre>
<p>最后虚拟dom将被ReactDOM转化为真实dom然后挂载到container上。</p>
<h1 id="第二步实现reactcreateelement">第二步：实现React.createElement</h1>
<p>Hello所在的位置可能是文本节点，也可能是其他子节点，观察后可以发现createElement其实就是参数到虚拟DOM的转化</p>
<pre><code class="language-javascript">// 简易的createElement
function createElement (type, props, children) {
    return {
        type,
        props: {
            ...props,
            children: children.map(child =&gt;
                typeof child === 'object' ? child : createElement(child)
            )
        }
    }
}
</code></pre>
<h1 id="第三步实现一个reactdomrender函数">第三步：实现一个ReactDOM.render函数</h1>
<p>得到虚拟dom之后，我们还可以继续实现一个简易的React.render函数</p>
<pre><code class="language-javascript">function render (element, container) {
    const dom = dom.type === &quot;TEXT_ELEMENT&quot;
        ? document.createTextNode(&quot;&quot;) : document.createElement(element.type)
    const isProperty = key =&gt; key !== &quot;children&quot;
    Object.keys(element.props).filter(isProperty).forEach(key =&gt; {
        dom[key] = element[key]
    })

    if (element.props &amp;&amp; element.props.children) {
        element.props.children.forEach(child = &gt; render(child, dom))
    }

    container.appendChild(dom)
}
</code></pre>
<p>通过以上三步，已经可以实现一个最小的React功能，将jsx渲染到页面上。</p>
<h1 id="第四步concurrent-mode并发模式">第四步：Concurrent Mode（并发模式）</h1>
<p>在前面三步，我们的dom元素的构建，appendChild方法的执行都是同步的，如果dom树规模过大，构建的过程会造成js主线程的阻塞，从而可能影响页面input用户的输入，或者动画的执行等高优先级任务，所以我们需要将任务拆分，做到不影响主线程其他任务的执行</p>
<pre><code class="language-javascript">let nextUnitOfWork = null

function workLoop (deadline) {
    let shouldYeild = false
    while (nextUnitOfWork &amp;&amp; !shouldYeild) {
        // 如果有下一个任务而且不需要等待主线程时间片空余，执行该任务，并且通过preformUnitOfWork返回下一个任务
        nextUnitOfWork = preformUnitOfWork(
            nextUnitOfWork
        )
        // deadline.timeRemaining()返回一个时间DOMHighResTimeStamp, 并且是浮点类型的数值，它用来表示当前闲置周期的预估剩余毫秒数，如果剩余时间小于1则不再有空闲时间，当前任务进入阻塞态
        shouldYeild = deadline.timeRemaining() &lt; 1
    }
    // 再次执行requestIdleCallback方法，进入下一轮渲染
    requestIdleCallback(workLoop)
}

requestIdleCallback(workLoop)
</code></pre>
<p>借助requestIdleCallback我们可以实现任务的拆分，在浏览器空闲时间进行低优先级任务的执行。</p>
<h1 id="第五步fiber架构">第五步：fiber架构</h1>
<p>为了对虚拟dom=&gt;真实dom的过程实现任务拆分，我们需要一种数据结构来表示我们的任务执行顺序，这也是fiber架构的除了requestIdleCallback之外的另一个基石<br>
<img src="https://chentianyuan.github.io/post-images/1604308808453.png" alt="fiber数据结构" loading="lazy"><br>
fiber架构创建了一个双向链表的数据结构，也可以叫fiber树，在首次任务执行时会使用深度优先遍历该树，每个节点生成一个链表节点（拥有child、parent、sibing三个指针），preformUnitOfWork通过该链表确定下一个nextUnitOfWork。遍历过程：从root节点开始，首先寻找有没有子节点，没有则寻找有没有sibling节点，如果也没有sibing节点，则回到上一个fiber节点，判断它是否存在sibing节点，直到指针回到root节点。<br>
第四步我们还剩下preformUnitOfWork函数没有实现，他的任务主要有以下三点</p>
<ul>
<li>执行任务，创建元素并添加至parentDom</li>
<li>为元素的children创建fiber树</li>
<li>选择下一轮需要执行的单元任务<br>
下面把以上逻辑抽象成代码</li>
</ul>
<pre><code class="language-javascript">// 1、从render函数中抽离出createDom函数，用于为当前任务创建真实dom
function createDom(fiber) {
  const dom =
    fiber.type == &quot;TEXT_ELEMENT&quot;
      ? document.createTextNode(&quot;&quot;)
      : document.createElement(fiber.type)
​
  const isProperty = key =&gt; key !== &quot;children&quot;
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name =&gt; {
      dom[name] = fiber.props[name]
    })
​
  return dom
}
// 2、render函数设置nextUnitOfWork为根节点的任务，render函数将在浏览器空闲时通过workLoop开始执行
function render (element, container) { /* TODO: set next unit of work */ }
// ↓↓↓↓↓↓↓↓↓↓↓
function render (element, container) {
    nextUnitOfWork = {
        dom: container,
        props: {
            children: [element]
        }
    }
}
</code></pre>
<p>然后，我们开始实现performUnitOfWork方法</p>
<pre><code class="language-javascript">function performUnitOfWork (fiber) {
    // 1、执行任务，创建元素并添加至parentDom
    if (!fiber.dom) {
        // 如果没有容器则根据fiber内容创建一个dom容器
        fiber.dom = createDom(fiber)
    }
    if (fiber.parent) {
        // 把当前节点插入父节点
        fiber.parent.dom.appendChild(fiber.dom)
    }
    // 2、为元素的children创建fiber树
    const elements = fiber.props.children
    let index = 0
    let prevSibling = null
    while (index &lt; element.length) {
        // 先创建子元素
        const element = elements[index]
        const newFiber = {
            type: element.type,
            props: element.props,
            parent: fiber,
            dom: null
        }
        if (index === 0) {
            // 第一个子元素即为当前fiber的子节点
            fiber.child = newFiber
        } else {
            // 第二个子元素通过sibling指针与上一个节点互为兄弟节点
            prevSibling.sibling = newFiber
        }
        // 记录上一个fiber节点
        prevSibling = newFiber
        index++
    }
    // 3、寻找下一个工作单元
    // 如果有子节点，直接返回字节点作为下一个工作单元
    if (fiber.child) return fiber.child
    let nextFiber = fiber
    while (nextFiber) {
        // 如果有兄弟节点，则返回兄弟节点作为下一个工作单元
        if (nextFiber.sibling) return nextFiber.sibling
        // 否则向上查询，查找父节点的是否有兄弟节点
        nextFiber = nextFiber.parent
    }
}
</code></pre>
<p>以上我们已经实现了一个简易版的不阻塞主线程高优先级任务的fiber架构。</p>
<h1 id="第六步render-and-commit-phases-提交渲染阶段">第六步：Render and Commit Phases （提交渲染阶段）</h1>
<p>上面的实现还存在一些问题，我们的fiber架构为了不阻塞页面渲染将创建和appendChild分解成了子任务，当我们出发渲染时，页面会出现dom元素一点一点更新的情况，导致用户看到的不是一个完整的渲染后的页面，而是看到页面一点一点地发生变更。<br>
因此，我们需要移除<code>fiber.parent.dom.appendChild(fiber.dom)</code>这个步骤，把这个任务进行一个收集，最后一次性执行。</p>
<pre><code class="language-javascript">function render (element, container) {
    // 记录fiber root节点，也就是我们的fiber tree
    wipRoot = {
        dom: container,
        props: {
            children: [element]
        },
    }
    nextUnitOfWork = wipRoot
}
let wipRoot = null

function workLoop (deadline) {
    // 当前没有剩余的需要执行的子任务时，执行commit，把真实dom渲染到页面上
    if (!nextUnitOfWork &amp;&amp; wipRoot) {
        commitRoot()
    }
}

// 提交
function commitRoot () {
    commitWork(wipRoot.child)
    // 防止内存泄漏
    wipRoot = null
}

// real commit
function commitWork (fiber) {
    if (!fiber) return
    const domParent = fiber.parent.dom
    domParent.appendChild(fiber.dom)
    // 递归执行appendChild
    commitWork(fiber.child)
    commitWork(fiber.sibling)
}
</code></pre>
<p>现在，我们把所有的appendChild操作从performUnitOfWork中进行了抽离，在完整的fiber树构建完毕之后，递归执行commitWork进行append操作。</p>
<h1 id="第七步reconciliation调和阶段">第七步：Reconciliation（调和阶段）</h1>
<p>到目前为止，我们仅完成了数据渲染到页面的整体结构，当我们的数据发生变化，删除或新增或修改元素，我们需要对更新后的fiber tree和之前的fiber tree进行比对，然后同步到页面上。</p>
<pre><code class="language-javascript">function commitRoot () {
    deletions.forEach(commitWork)
    commitWork(wipRoot.child)
    currentRoot = vipRoot
    wipRoot.child = null
}
function render (element, container) {
    wipRoot = {
        dom: container,
        props: {
            children: [element]
        },
        // 记录上一次commit的fiber树
        alternate: currentRoot
    }
    deletions = []
}
let currentRoot = null
let deletions = null
function performUnitOfWork (fiber) {
    // ...
    const elements = fiber.props.children
    reconcileChildren(fiber, elements)
}

// 从performUnitOfWork中抽离深度优先遍历的逻辑，从直接创建变成比较
function recpmcileChildren (wipFiber, elements) {
    let index = 0
    let oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child
    let prevSibing = null
    // 如果有oldFiber，要继续进行比较操作，删除原节点
    while (index &lt; elements.length || oldFiber !== null) {
        const element = elements[index]
        let newFiber = null
        // compare here
        const sameType = oldFiber &amp;&amp; element &amp;&amp; element.type == oldFiber.type
        if (sameType) {
            // update the node
            newFiber = {
                type: oldFiber.type,
                props: element.props, // 相同类型的节点取最新的props
                dom: oldFiber.dom,
                parent: wipFiber,  // 父节点被wipFiber所存储
                alternate: oldFiber, // 继续使用上次构建的Fiber节点
                effectaTag: 'UPDATE' // 标记update
            }
        }
        if (element &amp;&amp; !sameType) {
            // add this node
            newFiber = {
                type: element.type, // 更新节点类型
                props: element.props, // 取最新节点的props
                dom: null,
                parent: wipFiber, 
                alternate: null,
                effectTag: 'PLACEMENT'
            }
        }
        if (oldFiber &amp;&amp; !sameType) {
            // delete the oldFiber's node
            oldFiber.effectTag = 'DELETION'
            deletions.push(oldFiber)
        }

        if (oldFiber) {
            oldFiber = oldFiber.sibling
        }
        if (index === 0) {
            wipFiber.child = newFiber
        } else {
            wipFiber.sibling = newFiber
        }
    }
}

function commitWork (fiber) {
    if (!fiber) return
    const domParent = fiber.parent.dom
    if (fiber.effectTag === &quot;PLACEMENT&quot; &amp;&amp; fiber.dom != null) {
        dom.appendChild(fiber.dom)
    } else if (fiber.effectTag === &quot;UPDATE&quot; &amp;&amp; fiber.dom != null) {
        // 更新页面上的元素
        updateDom(fiber.dom, fiber.alternate.props, fiber.props)
    } else if (fiber.effectTag === &quot;DELETION&quot;) {
        domParent.removeChild(fiber.dom)
    }
    commitWork(fiber.child)
    commitWork(fiber.sibling)
}

const isEvent = key =&gt; key.startWith('on')
const isProperty = key =&gt; key !== &quot;children&quot; &amp;&amp; !isEvent(key)
const isNew = (prev, next) =&gt; key =&gt; prev[key] !== next[key]
const isGone = (prev, next) =&gt; key =&gt; !(key in next)
function updateDom (dom, prevProps, nextProps) {
    // Remove old or changed event listeners
    Object.keys(prevProps)
        .filter(isEvent)
        .filter(key =&gt; !(key in nextProps) || isNew(prevProps, nextProps)(key))
        .forEach(name =&gt; {
            const eventType = name.toLowerCase().substring(2)
            dom.removeEventListener(eventType, prevProps[name])
        })
    // Remove old properties
    Object.keys(prevProps)
        .filter(isProperty)
        .filter(isGone(prevProps, nextProps))
        .forEach(name =&gt; {
            dom[name] = &quot;&quot;
        })
    // Set or update new properties
    Object.keys(nextProps)
        .filter(isProperty)
        .filter(isNew(prevProps, nextProps))
        .forEach(name =&gt; {
            dom[name] = nextProps[name]
        })
    // Add event listeners
    Object.keys(nextProps)
        .filter(isEvent)
        .filter(isNew(prevProps, nextProps))
        .forEach(name =&gt; {
            const eventType = name.toLowerCase().substring(2)
            dom.addEventListener(eventType, nextProps[name])
        })
}
</code></pre>
<h1 id="第七步支持函数式组件function-components">第七步：支持函数式组件（Function Components）</h1>
<pre><code class="language-javascript">function App (props) {
    return &lt;h1&gt;Hi { props.name }&lt;/h1&gt;
}
const element = &lt;App name=&quot;foo&quot;&gt;
const container = document.getElementById(&quot;root&quot;)
ReactDOM.render(element, container)
</code></pre>
<p>当我们的组件不再是标签式jsx，而是函数式组件时，我们将其视为一种特殊的type类型，然后对划分任务阶段的performUnitOfWork函数进行改造</p>
<pre><code class="language-javascript">function performUnitOfWork (fiber) {
    const isFunctionComponent = fiber.type instanceof Function
    if (isFunctionComponent) {
        updateFunctionComponent(fiber)
    } else {
        updateHostComponent(fiber)
    }
    // ...
    function updateFunctionComponent (fiber) {
        // 执行函数，作为当前fiber节点的一个children属性，进入调和阶段
        const children = [fiber.type(fiber.props)]
        reconcileChildren(fiber, children)
    }
    function updateHostComponent (fiber) {/* 非函数式组件，交由调和函数，标记元素修改状态 */}
}

function commitWork (fiber) {
    // ...
    let domParentFiber = fiber.parent
    while (!domParentFiber.dom) {
        // 针对函数式组件，没有自身的dom时，将其要append的dom元素设为父元素的dom
        domParentFiber = domParentFiber.parent
    }
    const domParent = domParentFiber.dom
    // ...
    if (fiber.effectTag === &quot;DELETION&quot;) {
        commitDeletion(fiber, domParent)
    }

    function commitDeletion (fiber, domParent) {
        if (fiber.dom) {
            domParent.removeChild(fiber.dom)
        } else {
            commitDeletion(fiber.child, domParent)
        }
    }
}
</code></pre>
<h1 id="第八步支持react-hooks">第八步：支持react hooks</h1>
<p>在函数组件中使用hooks，此处实现一个最简易的useState hooks</p>
<pre><code class="language-javascript">// 首先初始化一些变量用于增强我们的fiber架构
let wipFiber = null // record prev function fiber
let hookIndex = null //
function updateFunctionComponent (fiber) {
    wipFiber = fiber
    hookIndex = 0
    wipFiber.hooks = []
}

function useState (initial) {
    const oldHook = 
        wipFiber.alternate &amp;&amp;
        wipFiber.alternate.hooks &amp;&amp;
        wipFiber.alternate.hooks[hookIndex]
    const hook = {
        state: oldHook ? oldHook.state : initial,
        queue: []
    }
    const action = oldHook ? oldHook.queue : []
    actions.forEach(action =&gt; {
        hook.state = action(hook.state)
    })
    // 首次执行setState时，react会将执行的action推入hook,queue
    // 当我们对函数组件进行fiber任务执行阶段时，action会从oldHook.queue中取出，并一个一个执行，并且更新到hook.state上，此时函数组件拿到的就是最新的state了
    const setState = action =&gt; {
        hook.queue.push(action)
        wipRoot = {
            dom: currentRoot.dom,
            props: currentRoot.props,
            alternate: currentRoot
        }
        nextUnitOfWork = wipRoot
        // hook重新创建
        deletions = []
    }
    wipFiber.hooks.push(hook)
    hookIndex++
    return [hook.state, setState]
}
</code></pre>
<h1 id="总结">总结</h1>
<p>实现一个简易的react步骤</p>
<ul>
<li>通过createElement实现jsx的转化</li>
<li>通过createElement转化得出的虚拟dom，递归实现ReacrDOM.render函数</li>
<li>通过requestIdleCallback实现任务的分段执行</li>
<li>因为直接分段的形式会使得用户看到不完整的页面。通过fiber架构，双向特殊链表，深度优先遍历，实现页面dom结构创建的分层和缓存，最后一次性递归append到页面</li>
<li>调和阶段对比oldFiber和newFiber的不同，实现新增，修改，删除三种页面常见的结构变化操作</li>
<li>支持函数式组件</li>
<li>支持建议的hooks</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react学习第三天]]></title>
        <id>https://chentianyuan.github.io/post/react-xue-xi-di-san-tian/</id>
        <link href="https://chentianyuan.github.io/post/react-xue-xi-di-san-tian/">
        </link>
        <updated>2020-10-26T08:44:28.000Z</updated>
        <summary type="html"><![CDATA[<p>react-router &amp;&amp; react hooks</p>
]]></summary>
        <content type="html"><![CDATA[<p>react-router &amp;&amp; react hooks</p>
<!-- more -->
<h1 id="一-为什么要使用hooks">一、为什么要使用hooks？</h1>
<p>1、无需在class组件中管理this，组件更轻量<br>
2、在一个函数中聚合</p>
<h1 id="二-内置的hooks">二、内置的hooks</h1>
<p>React提供的Hooks，仅允许在函数式组件中使用。</p>
<h5 id="usestate">useState</h5>
<p>useState接收state的默认值，返回该state和一个仅用于修改该state的函数。</p>
<h5 id="useeffect">useEffect</h5>
<p>useEffect包含了React的ComponentDidMounted，ComponentShouldUpdate等执行副作用函数的钩子，useEffect返回的函数会在渲染内容销毁时被触发。同事useEffect可以接收第二个参数，类似于vue的watch函数，当且仅当参数二发生变化时才会执行副作用函数。</p>
<h5 id="usecontext">useContext</h5>
<p>useContext接收一个context为参数，返回当前context注入的值，前提是在父级组件已经使用<code>&lt;Context.Provider&gt;</code> 包裹子组件，此时的useContext效果相当于之前使用context时的静态声明和this.context，useContext一方面提供了context上的值，另一方面标明了当前组件对context的依赖情况，当context内的属性发生变化时，即触发该组件的重渲染。（当某个值被多个组件所依赖，context可以提升我们组件的渲染性能）</p>
<h5 id="usecallback">useCallback</h5>
<pre><code class="language-javascript">function cacheEffectFn (EffectFn, deps = []) {
    // 第二个参数代表依赖数组，如果依赖数组为空，则代表第一个入参将在组件内被永久缓存
    return useCallBack(EffectFn, deps)
}
</code></pre>
<p>由于函数式组件在每次渲染时都会重新执行，在函数中正常声明的函数在渲染的时候每次都会被重新创建，当我们有节流函数保存了timer的时候，此时如果有其他state发生变化，重新触发函数组件的执行，那么之前的timer将不会影响这次重新创建的timer，因此，我们需要useCallback或者useRef来对我们的节流函数进行缓存。</p>
<h5 id="usememo">useMemo</h5>
<p>useMemo相比于useCallback的区别在于，useCallback是根据依赖（deps）缓存第一个入参（callback）的。useMemo是根据依赖（deps）缓存第一个入参（callback）的返回值的，例如</p>
<pre><code class="language-javascript">// 此时calcValue内的函数只会在首次渲染时或者依赖项count被改变时执行
// 节省了每次渲染时的内存消耗
const calcValue = React.useMemo(() =&gt; {
    return Array(10000).fill('').map(v =&gt; /* 一些大量的计算 */v)
}, [count])
</code></pre>
<h5 id="useref">useRef</h5>
<p>useRef返回一个可变的ref对象，其.current属性被初始化为传入的参数，返回的ref对象在组件的整个生命周期内保持不变。</p>
<pre><code class="language-javascript">const UseUseRef = () =&gt; {
    const inputElement = useRef(null)
    const focuHandle = () =&gt; {
        if (inputElement.current) {
            inputElement.current.focus()
        }
    }
    return (
        &lt;div className=&quot;content&quot;&gt;
            &lt;input ref={ inputElement }  placeholder=&quot;useRef API&quot;/&gt;
            &lt;button onClick={ focuHandle }&gt;&lt;/button&gt;
        &lt;/div&gt;
    )
}
</code></pre>
<p>相比于createRef(null)，useRef(null)将缓存ref.current所指向的dom对象，我们还可以用来缓存像函数或者大的堆变量以节省内存消耗。</p>
<h1 id="三-react-router">三、react-router</h1>
<p>react-router-dom是在react-router的基础上进行的封装，下面列举一些常见的路由组件</p>
<pre><code class="language-html">&lt;!-- 提供history路由，操作history api控制路由变化，同时根据包裹的路由情况渲染对应路由 --&gt;
&lt;BrowserRouter /&gt;
&lt;!-- 最常用的路由组件 --&gt;
&lt;Route&gt;
&lt;!-- 用于装饰组件，装饰后组件内部可以在this.props内获取到当前的路由信息 --&gt;
&lt;withRouter&gt;
&lt;!-- Link\NavLink导航 --&gt;
&lt;Link to='/'&gt;
&lt;NavLink to='/'&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react学习第二天]]></title>
        <id>https://chentianyuan.github.io/post/react-xue-xi-di-er-tian/</id>
        <link href="https://chentianyuan.github.io/post/react-xue-xi-di-er-tian/">
        </link>
        <updated>2020-10-24T06:37:46.000Z</updated>
        <summary type="html"><![CDATA[<p>高级指引！</p>
]]></summary>
        <content type="html"><![CDATA[<p>高级指引！</p>
<!-- more -->
<h1 id="一-代码分割">一、代码分割</h1>
<h1 id="二-context使用">二、context使用</h1>
<p>类似于vue的provider和inject属性，react提供了React.createContext方法，创建一个上下文组件，被该组件所包裹的组件可以无需通过props传递属性，直接深传递进组件树。</p>
<pre><code class="language-javascript">const ThemeContext = React.createContext(context)
class App extends React.componet {
    render () {
        return (
            &lt;ThemeContext.provider&gt;
                &lt;Children /&gt;
            &lt;/ThemeContext.provider&gt;
        )
    }
}
class Children extends React.Component {
    render () {
        return (
            &lt;div theme={this.context}&gt;&lt;/div&gt;
        )
    }
}
</code></pre>
<p>context很方便，但是会使得组件的复用性变差，因此context一般用于管理应用的locale，theme等状态。<br>
而对于业务组件，为了防止props层层传递，其实还有一种方法。</p>
<h1 id="三-控制反转">三、控制反转</h1>
<p>当你的组件嵌套较深，而且有某个state仅在较底层的组件使用时，我们可以将组件作为props传递，从而将底层组件提升至较为高层的组件中声明。然后在子组件中使用this.props[组件名]来将其渲染</p>
<pre><code class="language-javascript">function Page(props) {
  const user = props.user;
  const userLink = (
    &lt;Link href={user.permalink}&gt;
      &lt;Avatar user={user} size={props.avatarSize} /&gt;
    &lt;/Link&gt;
  );
  return &lt;PageLayout userLink={userLink} /&gt;;
}

// 现在，我们有这样的组件：
&lt;Page user={user} avatarSize={avatarSize} /&gt;
// ... 渲染出 ...
&lt;PageLayout userLink={...} /&gt;
// ... 渲染出 ...
&lt;NavigationBar userLink={...} /&gt;
// ... 渲染出 ...
{props.userLink}
</code></pre>
<h1 id="四-错误边界">四、错误边界</h1>
<p>如果一个class组件定义了static getDerivedStateFromError或者componentDidCatch这两个生命周期方法中的任意一个时，那么它就变成了一个错误边界，当子组件抛出错误时，会被最近的错误边界所捕获。</p>
<pre><code class="language-javascript">class ErrorBoundary extends React.Component {
    constructor (props) {
        super(props)
        this.state = { hasError: false }
    }
    static getDerivedStateFromError () {
        // 更新 state 使下一次渲染能够显示降级后的UI
        return { hasError: true }
    }

    render () {
        if (this.state.hasError) {
            return &lt;ErrorComponent/&gt;
        }

        return this.props.children
    }
}
</code></pre>
<h1 id="五-ref">五、ref</h1>
<p>通过React.createRef方法可以创建一个ref对象，然后在指定的组件上声明ref属性为该ref对象之后，我们便可以通过该ref上的current属性，获取当前组件的真实dom元素</p>
<pre><code class="language-javascript">class Child extends React.Component {
  constructor () {
    super();
    this.childRef = React.createRef()
  }

  componentDidMount () {
    window.a = this.childRef
    console.log(this.childRef.current)
  }

  render () {
    return (
      &lt;section ref={this.childRef}&gt;
        i am child
      &lt;/section&gt;
    )
  }
}
</code></pre>
<p>另外，当创建的ref作用于组件时，那么this.ref.current将会返回组件的实例。</p>
<h1 id="六-hoc高阶组件">六、HOC高阶组件</h1>
<p>HOC组件接收一个组件和多余参数，进行AOP面向切面编程，返回一个新的组件，HOC是纯函数，没有副作用，当我们的输入相同时其一定返回一样的结果，它不会修改传入的组件，也不会继承，而是通过包装提供通用逻辑，得到一个被包装后的原始组件。</p>
<pre><code class="language-javascript">function logProps (Component) {
    return class extends React.Component {
        comonentDidUpdate (prevProps) {
            console.log(`prevProps: ${prevProps}`);
            console.log(`props: ${this.props}`);
        }
        return &lt;Component { ...this.props } /&gt;;
    }
}
</code></pre>
<h1 id="七-react-diff算法">七、react diff算法</h1>
<p>以后详细看看，粗浅地看貌似和vue的diff差不多，只是少了头尾节点对比的过程，也有通过key进行原地复用的优化，还有同层级比较的优化。</p>
<h1 id="八-render-props">八、render props</h1>
<p>当我们有一个通用的高阶组件，被其包裹的组件将包含某些能力。当被包裹的组件无需读取高阶组件包含的状态时，我们可以在高阶组件内部直接读取this.props.children来渲染插入的自定义组件，但是当自定义组件需要用到高阶组件的状态，上述方法就不适用了，我们可以通过给高阶组件一个render props，再将高阶组件的state传入自定义组件中。</p>
<pre><code class="language-javascript">class HOCComponent extends React.Component {
    constructor (props) {
        super(props)
    }

    componentDidMounted () {
        console.log('hello world !')
    }

    render () {
        return (
            &lt;&gt;
                {this.props.render(this.state)}
            &lt;/&gt;
        )
    }
}

class Child extends React.Component {}
class Wrap extends React.Component {
    render () {
        return (
            &lt;HOCComponent render={
                state =&gt; (
                    &lt;Child hocState={state}&gt;
                )
            }/&gt;
        )
    }
}
</code></pre>
<h1 id="九-使用proptypes对props进行类型检查">九、使用propTypes对props进行类型检查</h1>
<p>类似于vue的prop属性，props是组件的静态属性，用于校验传入的props类型，另外，通过defaultProps静态属性还可以对传入的props赋予默认值，一个普通的propTypes如下：</p>
<pre><code class="language-javascript">import PropTypes from 'prop-types';
class Greeting extends React.Component {
    static propTypes = {
        name: PropTypes.string.isRequire,
        age: PropTypes.oneOf([
            PropTypes.string,
            PropTypes.number
        ])
    }
    static defaultProps = {
        name: 'zw'
    }
    render () { return (&lt;div&gt;{ this.props.name }&lt;/div&gt;) }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react学习第一天]]></title>
        <id>https://chentianyuan.github.io/post/react-xue-xi-di-yi-tian/</id>
        <link href="https://chentianyuan.github.io/post/react-xue-xi-di-yi-tian/">
        </link>
        <updated>2020-10-22T02:31:14.000Z</updated>
        <summary type="html"><![CDATA[<p>react哲学！</p>
]]></summary>
        <content type="html"><![CDATA[<p>react哲学！</p>
<!-- more -->
<h1 id="一-react的代码编写两种方式">一、react的代码编写两种方式</h1>
<p>1、自顶向下<br>
当前应用比较小且比较简单的情况下，我们设计了组件模块之后，可以采用自顶向下的构建形式，最先构建上级组件，然后将静态数据通过props传入更为细粒度的组件。<br>
这种方式比较简单方便。<br>
2、自底向上<br>
当前涉及的业务比较复杂，设计了组件模块之后，可以先构建精细的小模块，然后通过组装的形式，慢慢地将其构建成一个大型应用。<br>
这种方式方便在构建细粒度的组件时，同事编写测试代码。</p>
<h1 id="二-react中的props和state">二、react中的props和state</h1>
<p>props是静态数据，改动无法被监听，state的数据变化会重新触发render函数，页面重新渲染。<br>
state是在组件内被内部管理的<br>
props是传递给组件的，类似于函数形参，但是它也会影响页面的渲染<br>
我们应该尽量确定UI state的最小状态，避免多余的state影响代码的可维护性<br>
判断某块数据是静态还是动态的判断准则有以下几点：<br>
<strong>1，该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。<br>
2，该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。<br>
3，你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</strong></p>
<h1 id="三-thissetstate是同步还是异步的">三、this.setState是同步还是异步的</h1>
<p>异步的！下面的操作最终得到的结果count最后会为1，而不是预期的3</p>
<pre><code class="language-javascript">// this.state.count 0
this.setState({ count: this.state.count + 1 })
// this.state.count 0
this.setState({ count: this.state.count + 1 })
// this.state.count 0
this.setState({ count: this.state.count + 1 })
// this.state.count 1

// 相当于
// Object.assign(
//     this.state,
//     { count: this.state.count },
//     { count: this.state.count },
//     { count: this.state.count }
// )
</code></pre>
<p>在执行setState时，this.state.count取值都还是0，react不会更新this.state.count，直到组件被重新渲染，当我们有这种需要依赖当前更新后的state去修改state的情况，可以通过给setState传入一个函数，而非对象来解决。</p>
<pre><code class="language-javascript">// this.state.count 0
this.setState(state =&gt; { count: this.state.count + 1 })
// this.state.count 1
this.setState(state =&gt;{ count: this.state.count + 1 })
// this.state.count 2
this.setState(state =&gt;{ count: this.state.count + 1 })
// this.state.count 3
</code></pre>
<p>setState的函数调用是分批的，会先执行updater函数，再执行下一个setState，可以解决上述state更新不及时的问题。</p>
<h1 id="四-为什么要继承reactcomponent">四、为什么要继承React.component</h1>
<p>一个普通的无状态组件其实可以不继承React.componet，而仅仅表示为一个函数，返回模板对象<br>
但是一个有状态的组件（props||state||context||refs）是一定要继承自ReactComponent的。</p>
<pre><code class="language-javascript">function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
ReactComponent.prototype.isReactComponent = {};
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};
</code></pre>
<p>通过源码可知，props，state，setState这些核心的api都是来源于ReactComponent的。</p>
<h1 id="五-确定-state-放置的位置">五、确定 state 放置的位置</h1>
<p>1、首先找到承载依赖该state所有组件的共同的父组件<br>
2、使用一个新的组件包裹该通用的父组件<br>
3、将state提升至该父组件<br>
4、父子组件通过props，子组件通过props修改父组件的数据，通过this.props获取数据，父组件通过向组件标签添加属性，传入props</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[组件库搭建总结]]></title>
        <id>https://chentianyuan.github.io/post/zu-jian-ku-she-ji-shang-de-tan-suo/</id>
        <link href="https://chentianyuan.github.io/post/zu-jian-ku-she-ji-shang-de-tan-suo/">
        </link>
        <updated>2020-06-23T03:11:16.000Z</updated>
        <summary type="html"><![CDATA[<p>微医门户在移动端组件库方向上的探索</p>
]]></summary>
        <content type="html"><![CDATA[<p>微医门户在移动端组件库方向上的探索</p>
<!-- more -->
<h2 id="序言">序言</h2>
<p>来公司两年了，见证了公司组件库从无到有，从1.0到2.0的变迁过程，组件库已有1500+次提交，承载了门户技术部数个移动端项目，也算得上是一个经过考验的组件库了。</p>
<p>组件库内的组件固然重要，但是整体组件库的架构设计更是一个高可用，易扩展组件库的核心，那么应当如何搭建一个优质的组件库？</p>
<h1 id="0-组件库的价值">0、组件库的价值</h1>
<p>在应用端的体现：统一视觉规范，保证产品体验的一致性。<br>
在开发侧的体现：组件的可复用性削减了开发成本，也变相地减小了页面及项目体积。</p>
<h1 id="1-typescript支持">1、typescript支持</h1>
<p>相比于1.0的版本，wandui2.0采用了ts的写法，强类型的校验可以将许多语法语义上的错误扼杀在萌芽之中。类型的指定也像是注释一般增强了代码的可读性。另外，在开发完成之后通过指定<code>package.json</code>内的<code>types</code>字段，配合编辑器还有导入的语法提示功能，组件库内置的组件一览无余。<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg28ixf27fj317i0dydj7.jpg" alt="语法提示" loading="lazy"></p>
<h1 id="2-一键组件生成">2、一键组件生成</h1>
<pre><code class="language-json">{
    &quot;create&quot;: &quot;node build/create-component&quot;
}
</code></pre>
<p>一键生成新的组件规则，仅需执行一行<code>npm run create</code>，通过命令行inquiry式调用，传入需要新生成的组件名，脚本便会通过读取模板，进行新的组件的初始化，包括生成</p>
<ul>
<li>组件主文件</li>
<li>组件样式文件</li>
<li>组件文档</li>
<li>将组件添加进路由</li>
</ul>
<p>等等一系列重复操作，开发人员仅需关注组件本身的实现，大大提升了开发者的开发效率。<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg28t8tgzpj31d50u07nb.jpg" alt="一键组件生成" loading="lazy"></p>
<h1 id="3-打包配置">3、打包配置</h1>
<h2 id="31-为了实现按需加载的处理">3.1、为了实现按需加载的处理</h2>
<p>为了实现按需加载引入，我们常用<code>babel-plugin-component</code>或<code>babel-plugin-syntax-dynamic-import</code>这两个babel插件来使得<code>import { WandUploader } from @weiyi/wand-ui</code>在打包阶段转化成<code>import /node_modules/@weiyi/wand-ui/libaryName/uploader/index.js</code>+组件css引入（通用css会从libaryName下引入）来实现。<br>
因此我们要为每个组件作为打包出index.js和组件自身的的css文件，为此在按需打包的配置中我们为组件设置单独入口，样式文件使用<code>MiniCssExtractPlugin</code>来实现拆分，最后得到如下效果。</p>
<h2 id="32-组件库的通用样式">3.2、组件库的通用样式</h2>
<p>当业务方使用按需加载的方式引入我们的组件库，如果每个组件都对组件库通用样式进行引用，无疑会有大量的重复样式代码，由于<code>babel-plugin-component</code>插件已经提供了style选项，当该选项设置为<code>true</code>时，会将组件库通用样式额外引入，因此，为了单独打包出一份通用css文件，我们引入了gulp额外为通用css进行一次打包。</p>
<pre><code class="language-javascript">// less编译
gulp.task('css', done =&gt; {
  gulp
    .src('../../src/styles/base.less')
    .pipe(less())
    .pipe(concat('base.css'))
    .pipe(autoprefixer({
      overrideBrowserslist: ['last 2 versions', 'ie &gt; 8']
    }))
    .pipe(cleanCSS())
    .pipe(rename(function (path) {
      path.dirname = path.dirname.replace('less', 'css')
    }))
    .pipe(gulp.dest('../../lib/theme-chalk/'))

    done()
})
</code></pre>
<h2 id="33-获取运行时依赖">3.3、获取运行时依赖</h2>
<p>配置中需要外置化vue，防止vue被打包进入组件bundle中，而是通过运行时再去外部获取这些扩展依赖，配合指定<code>package.json</code>中的peerDependencies，强制要求接入方对我们外置的扩展依赖进行安装和打包。</p>
<pre><code class="language-javascript">// webpack.base.conf.js
externals: [
    {
        vue: {
        root: 'Vue',
        commonjs: 'vue',
        commonjs2: 'vue',
        amd: 'vue'
        }
    }
]
// package.json
&quot;peerDependencies&quot;: {
    &quot;vue&quot;: &quot;&gt;=2.5.15&quot;
}
</code></pre>
<h1 id="4-组件库文档">4、组件库文档</h1>
<p>一份优质的文档是一个成功的组件库的基础，element-ui的官网文档是经受了无数厂商的考验的，仔细观察可以发现element-ui的组件案例和组件文档是一一对应的，难道element-ui的组件demo写了两次？仔细阅读后可以发现，element-ui的文档路由是使用的md类型的文件，而在打包配置中指定了一个自定义的md-loader来处理该路由文件，md文件中的被<code>:::demo</code>和<code>:::</code>所包裹的代码块会被执行并编译，内部执行流程大概是这个样子的：<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2bn9a1puj31p40kkthd.jpg" alt="md-loader流程图" loading="lazy"><br>
在展示demo的项目里，我们只需要注册<code>demo-block</code>组件，并提供<code>source</code>插槽承载编译后的组件demo<br>
，<code>highlight</code>插槽承载md中的源代码，即可得到<strong>文档即demo</strong>的效果了。效果图：<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2btuiacvj31rg0u04gm.jpg" alt="文档即demo" loading="lazy"><br>
另一个值得权衡的问题是，文档是新开一个项目还是就放在组件库的项目里？<br>
如果放在项目里，组件库一大，项目会略显臃肿，并且每次跑项目都需要把组件进行重新编译，速度堪忧。而如果分离出一个新的项目，则享受不到开发时热更新的遍历，需要把打包文件频繁输出，才能实时看到组件的效果，而且另起一个工程也是有成本的，需要安装两次通用的依赖。而且从维护成本的角度来看，还是放在一个项目内会方便得多，除非你的目标是做一个大而美的业界组件库，而不是为了业务需要快速迭代的产物。（然而没有资本支撑，估计也没人愿意做这么一套东西）</p>
<h1 id="5-发包规范">5、发包规范</h1>
<p>早期wand-ui2.0刚出时采用指定负责人手动发包的形式，当时刚出的组件库有很多小问题，频繁的发包步骤十分繁琐。后期为了解决这一问题，项目使用gitlab-ci，配合gitlab-runner，在yml配置文件中划分了打包和发包两个stage，打包机完成文档和组件库打包后进行压缩，再远程传输到虚拟机，执行publish脚本，比对线上和当前<code>package.json</code>内的组件库版本，检测到落后后自动publish，再也不用手动发包了。</p>
<h1 id="6-轻量的组件库脚手架">6、轻量的组件库脚手架</h1>
<p>文档打包，组件打包，全量、按需、开发、生产，<code>require(&quot;package.json&quot;).script</code>会越来越大build目录下的文件也会越来越多，使项目变得臃肿不堪。我们尝试对组件库基本不再修改的打包配置进行了封装，通过命令式的调用形式，读取项目配置，执行命令内置的打包配置，即可完成打包。项目内甚至无需build目录。<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2cu7qwm9j310u0t6gsx.jpg" alt="" loading="lazy"><br>
同时我们还抽离了<code>wand-template</code>一份组件库最小单元的模板，配合抽离的<code>wand-cli</code>，可以一键式地生成一个组件即demo的vue移动端组件库，并提供了ts环境开发，提供md即文档的特性。<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2csubtc9j30u014cjxz.jpg" alt="" loading="lazy"></p>
<h1 id="结语">结语</h1>
<p>一个好的组件库不仅在组件本身的通用性，易用性，也在于整体组件库架构设计的可重用性，规范性，易扩展性，市面上的组件库层次不齐，组件库搭建可以参考学习业内如element-ui，ant-design，vant等优秀组件库的设计理念，如果有错误烦请在评论区指正交流，谢谢。</p>
<blockquote>
<p>文中组件库由wand-ui2.0开发小分队共同完成。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[致她]]></title>
        <id>https://chentianyuan.github.io/post/zhi-ta/</id>
        <link href="https://chentianyuan.github.io/post/zhi-ta/">
        </link>
        <updated>2020-06-18T15:57:15.000Z</updated>
        <summary type="html"><![CDATA[<p>一转眼，到今天为止我们在一起已经两周年了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一转眼，到今天为止我们在一起已经两周年了。</p>
<!-- more -->
<h1 id="初端">初端</h1>
<p>时间回到2018年6月18日，那时天气还没有现在这么热，也许是这两年全球变暖又加剧了，端午节的前一天，我还住在博奥城的地下室里，不知道出于什么缘故，或许只是那天的一句玩笑，”端午我去上饶找你玩啊“，然后就真的买了一张去上饶的火车票。那时还在实习的我没什么钱，来回的车票已经是我半个月的生活费，然而我还是买了。后面的故事很奇妙，我只记得晚上睡得很香，从上大学以来，第一次睡得那么舒适安稳。</p>
<h1 id="变故">变故</h1>
<p>因为地理位置的缘故，加上工作和学业原因，19年我们很少人在一起。我在努力工作，你在努力考研，最后我们都拿到了满意的结果，如果所有的事情都往好的方面发展该有多好。最疼我的爷爷外婆相继离开了我，外婆更是受尽了病痛的折磨，我知道男子汉不该哭的，爸爸妈妈比我还伤心，应该安慰他们的，天堂没有病痛的，在打通你的电话听到你的声音的时候我还是崩溃了，所有的难受都释放出来了，早上上班还和同事嘻嘻哈哈的我坐在寝室外面的台阶上哭得语无伦次，我不是没有其他朋友，这些情绪只有当我在你身边才能真真切切得展现然后离开。我们因为很多人而变得更好，我因为有你而变得安稳。</p>
<h1 id="如今">如今</h1>
<p>现在2020年6月19日，12点37分，两年过去了，一切又走上了正轨，再想想两年前在一起的意义突然变得模糊却又渐渐清晰了，喜欢这个词会永远是我们在一起的原因，但是对我来说不是意义所在。人这一生可能会喜欢很多人，如果喜欢变成了枷锁，那么人也会慢慢失去喜欢别人的能力，最后连最喜欢的人也喜欢不起来。人类是有思想有情感的动物，喜欢是与生俱来的能力，喜欢一个人得像一个装着纸条的小瓶子，悄悄得存放着内心的秘密，但是喜欢又是约束，为了你，得愿意把最大最精致的瓶子给你放，可以抛弃所有的其他瓶子，唯独这个不能丢，毕竟这个是最好的，最真切的一直陪在你身边的瓶子，有这个瓶子在人就会变得平静，变得安稳，变得温暖。</p>
<h1 id="未来">未来</h1>
<p>未来充满着不可控性和不确定性，未来也许会很艰难，也许会充满痛苦，每件事出现的概率都是有可能的，不过是概率大小的问题。不过，事在人为，兵来将挡水来土掩，问题一定会解决的。未来有你一点都不可怕。</p>
<p>我一直不懂什么是爱情，以至于两年前即便是说出这两个字我都羞于启齿，不过两年时间过去了，我才有一点点理解，对我来说，爱情不是虚无缥缈的东西，我们面对彼此时的喜怒哀乐，一起生活的酸甜苦辣，那些真真切切流逝的互相陪伴的时间，这就是爱情。</p>
<blockquote>
<p>愿陪你度过漫长岁月<br>
2020/06/19</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[页面适配后的真相]]></title>
        <id>https://chentianyuan.github.io/post/ni-zhi-dao-ji-chong-ye-mian-gua-pei-fang-an/</id>
        <link href="https://chentianyuan.github.io/post/ni-zhi-dao-ji-chong-ye-mian-gua-pei-fang-an/">
        </link>
        <updated>2020-04-24T10:44:22.000Z</updated>
        <summary type="html"><![CDATA[<p>市场上的移动端产品层出不穷，如何一套代码应对不同分辨率的手机？</p>
]]></summary>
        <content type="html"><![CDATA[<p>市场上的移动端产品层出不穷，如何一套代码应对不同分辨率的手机？</p>
<!-- more -->
<h1 id="移动端的适配方案">移动端的适配方案</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6fpqm6m2j31ik0r44n5.jpg" alt="" loading="lazy"><br>
电影天堂的页面并没有做适配，但是放到移动端访问，页面进行了自动的缩放，包括字体，但是设置同样的字体时会员页的字体并没有被缩放？真相是？</p>
<h2 id="移动端的三种像素">移动端的三种像素</h2>
<p>移动端最开始其实只有两种像素</p>
<h3 id="物理像素device-pixels">物理像素（device pixels）</h3>
<p>指屏幕的物理像素，又叫设备像素，任何设备的物理像素都是固定的。</p>
<h3 id="css像素css-pixels">css像素（css pixels）</h3>
<p>这个比较好理解，就是我们常写的100px，200px代码中所指的像素，它和物理像素之间的换算取决于屏幕的特性（是否为高密度屏），比如，在普通屏幕和苹果的视网膜屏幕上，2px所代表的物理像素是不同的<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6furft4vj30eb07ymxo.jpg" alt="" loading="lazy"><br>
普通屏幕2px等于2个物理像素，而视网膜屏2px等于8个物理像素，如果用户进行手动放大，一个px还会相当于更多个物理像素。</p>
<h3 id="设备像素比dpr">设备像素比（dpr）</h3>
<p>又叫dpr，apple的dpr等于2，因为dpr = 物理像素 和 设备独立像素（也就是css像素）的比值。</p>
<h2 id="屏幕的三种视口">屏幕的三种视口</h2>
<h3 id="布局视口-和-视觉视口">布局视口 和 视觉视口</h3>
<h4 id="布局视口">布局视口</h4>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6g0p4q8sj309c07xdg2.jpg" alt="" loading="lazy"><br>
一般移动设备的浏览器都默认设置了一个 viewport 元标签，定义一个虚拟的布局视口（layout viewport）早期为了兼容pc端的网页，屏幕厂商都把布局视口统一设置为980px，我们可以通过<br>
<code>docuemnt.documentElement.clientWidth</code> 来获取</p>
<h4 id="视觉视口">视觉视口</h4>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6g1en1tgj308z084q36.jpg" alt="" loading="lazy"><br>
视觉视口就是用户可以看到的真实屏幕的视口大小<br>
当视觉视口小于布局视口时，屏幕会进行一个自动的缩放，来保证大的布局也能在页面上完全显示。<br>
缩放比例 = 布局视口 / 视觉视口<br>
所以当我们在移动端看电影天堂的页面，是经过了自动缩放的，如果设置<code>&lt;meta name=&quot;view-port&quot; content=&quot;375&quot; &gt;</code>会发现，字体大小恢复了，页面需要滚动来查看视觉视口外的内容</p>
<h3 id="理想视口">理想视口</h3>
<p>慢慢的，浏览器厂商发现布局视口的默认宽度980px并不是一个理想的宽度，因此浏览器厂商引入了理想视口的概念，它对设备而言是最理想的布局视口尺寸。显示在理想视口中的网站具有最理想的宽度，用户无需进行缩放。理想视口的值其实就是屏幕分辨率（对应的像素叫设备逻辑像素）的值（不等同于视觉视口，视觉视口会小于或等于屏幕分辨率）<br>
<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code><br>
这行代码可以保证理想视口和布局视口一致。<br>
移动端我们常用视口原标签来保证我们的网页不会因为布局视口或者用户的手指操作而缩放<br>
<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1&quot;&gt;</code></p>
<h2 id="倍图">倍图</h2>
<p>以下是常见的设备像素比<br>
普通密度桌面显示屏：devicePixelRatio = 1<br>
高密度桌面显示屏(Mac Retina)：devicePixelRatio = 2<br>
主流手机显示屏：devicePixelRatio = 2 or 3<br>
也就是之前说的dpr，在不同的显示屏下，设备像素比不同，如果统一用2倍图（宽高100的图，分辨率是200*200）@2x，在普通显示屏会有色彩聚集的感觉，因为用1个物理像素来描绘4个图片像素，但是在设备像素比为3的显示屏，相当于用9个物理像素描绘4个图片像素，图片会有失真的感觉，因此这时就要使用3倍图@3x甚至@4x来避免图片的失真。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[秘技：图片领域]]></title>
        <id>https://chentianyuan.github.io/post/mi-ji-tu-pian-ling-yu/</id>
        <link href="https://chentianyuan.github.io/post/mi-ji-tu-pian-ling-yu/">
        </link>
        <updated>2020-04-24T06:01:59.000Z</updated>
        <summary type="html"><![CDATA[<p>万物皆二进制，图片的<br>
jpeg/bmp/png/webp</p>
]]></summary>
        <content type="html"><![CDATA[<p>万物皆二进制，图片的<br>
jpeg/bmp/png/webp</p>
<!-- more -->
<h1 id="图片属性要素">图片属性要素</h1>
<p>一张图片的组成部分，通常有</p>
<ul>
<li>图片格式 （jpeg/bmp/png/webp）</li>
<li>图片大小（大小和尺寸是不一样的）</li>
<li>像素（也叫尺寸，像素可以理解为像素点，无论图片怎么放大缩小，图片的像素点是不变的）</li>
<li>dpi（每英寸的像素，也叫扫描精度，web上大部分的图片都是72dpi，也就是每英寸72个像素。但是打印照片时，比如一张4<em>6英寸的照片，扫描精度必须大于300dpi，那么文件的尺寸应该是（4*300）</em>（6*300）= 1200 * 1800 像素）</li>
<li>颜色模式（RGB，RGBA...）<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge4xioff62j30m80jejti.jpg" alt="图片示例" loading="lazy"><br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge4x40cimoj30hs0emmy9.jpg" alt="detail" loading="lazy"></li>
</ul>
<h1 id="前端应用">前端应用</h1>
<h3 id="1-gif埋点">1、gif埋点</h3>
<p>百度统计的埋点方式是在首屏引入一个三方的js，然后这个三方的js会种下一个三方的uuid cookie在他们的域下，标识一个用户，每到一个页面会new一个image对象，请求这张图片时会带上前面的cookie，并带上页面数据。那么为什么要使用gif来上报埋点参数呢？<br>
大致原因如下：</p>
<ul>
<li>image.src天然支持跨域</li>
<li>图片请求优先级低，不占用ajax请求限额，不阻塞页面加载</li>
<li>相对ajax GET请求较为轻量</li>
<li>1x1像素是最小的合法图片，而且图片最好是透明的，不影响页面显示效果，而jpeg是不支持透明色的，jpeg的颜色模式是rgb可以直接排除，剩下bmp，png，gif。因为任何一张图片二进制编码都有一些必要的结构体标头，来标识图片信息，最后通过比对，同等条件下gif的必须标头仅43个字节，png67个，bmp74个，因此gif才是最佳选择</li>
</ul>
<h3 id="2-图片压缩">2、图片压缩</h3>
<p>在使用图片时，我们常常要对图片进行一次压缩，不同的图片类型，压缩方式，都会影响图片的压缩效果。</p>
<h4 id="png">png</h4>
<p>png图片颜色模式rgba，web应用中通常使用的是png8，也就是8位深度的png图片，位深度是每个像素所需要的像素大小。<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge4yvad06ej30sb099n03.jpg" alt="" loading="lazy"><br>
位深度越大，图片的细腻程度越高，当位深度是1，那么每个像素都由0和1来表示，那么也就只能表示黑白的图片了<br>
不同的位数其像素计算的规则不同<br>
8位：  2^8 = 2^2(B) 2^3(G) 2^3(R) = 256  (256色)    可以总共显示256种颜色<br>
16位：2^16 = 2^5(B) 2^6(G) 2^5(R) =  65536    可以总共显示65536种颜色<br>
24位：2^24 = 2^8(B) 2^8(G) 2^8(R) =  16777216    可以总共显示16777216种颜色<br>
32位：Alpha透明度 + 24位<br>
用图片像素乘上图片位数即为这张原始图片所占的字节数，当然可以经过一层压缩。<br>
png的压缩属于无损数据压缩，在保持图片质量的同时，还减少了图片的体积，8位支持alpha透明（只有透明和不透明），而32位有2^8种透明程度。png现常用于web上的logo，icon等图片中</p>
<h4 id="jpegjpg">jpeg&amp;jpg</h4>
<p>jpeg其实就是jpg，在web应用中不太常见，采用的是有损压缩方式，可能会导致图片失真，颜色规则rgb，不支持透明色，位深度现在也只有24位，但是相比于png-24，jpeg的无损压缩可以移除人的肉眼无法识别的图片细节，对色彩丰富的图片有更好的压缩效果</p>
<h4 id="bmp">bmp</h4>
<p>bmp原始图片，通常不采用压缩，图片质量也是最高的</p>
<h4 id="webp">webp</h4>
<p>webp支持有损和无损压缩两种压缩形式，将jpeg和png转为webp之后，实际体积会大幅缩小，webp通过分块和帧内预测的方法，对原有图片进行处理，比jpeg上使用的Huffman encoding表现得更为出色，唯一的缺点就是浏览器兼容性不好。</p>
<h4 id="通用图片选择方法">通用图片选择方法</h4>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge4zjpeug1j30gt09njsc.jpg" alt="" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<p>前端在埋点上对图片的选择缘由<br>
前端常见图片格式的分别<br>
现在公司使用的kano系统应该是根据ua来判断当前浏览器对webp的支持程度，统一返回webp的图片了~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一天一道算法题系列（4.10-5.10）]]></title>
        <id>https://chentianyuan.github.io/post/yi-tian-yi-dao-suan-fa-ti-xi-lie-410-510/</id>
        <link href="https://chentianyuan.github.io/post/yi-tian-yi-dao-suan-fa-ti-xi-lie-410-510/">
        </link>
        <updated>2020-04-10T15:59:29.000Z</updated>
        <summary type="html"><![CDATA[<p>第二个30天，士兵们，新一轮的战斗开始了</p>
]]></summary>
        <content type="html"><![CDATA[<p>第二个30天，士兵们，新一轮的战斗开始了</p>
<!-- more -->
<h1 id="20200410">20200410</h1>
<p><strong>题型：双指针 | 库函数</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdp4dnxb14j30uk0u0myh.jpg" alt="" loading="lazy"><br>
思路：<br>
1、统计每个单词的左右边界，i，j最后反向插入即可<br>
2、利用库函数split，过滤空格，reverse反正得到结果</p>
<h1 id="20200411">20200411</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqal0bkyoj319k0nu3z8.jpg" alt="" loading="lazy"><br>
<strong>题型：双指针，数学</strong></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  let result = []
  if (nums.length &lt; 3) return result
  // 顺序排序
  nums = nums.sort((a, b) =&gt; a - b)
  for (let i = 0; i &lt; nums.length; i++) {
    // 首个元素大于0可以不用再比了
    if (nums[i] &gt; 0) return result
    // 和上个元素相同，避免重复解
    if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) {
      continue
    }
    let left = i + 1
    let right = nums.length - 1
    while (left &lt; right) {
      var total = nums[i] + nums[left] + nums[right]
      if (total === 0) {
        // 先承认该数
        result.push([nums[i], nums[left], nums[right]])
        // 避免重复解，只需要在得到解之后，遇到相同数的时候继续向后移动即可避免重复解
        while (left &lt; right &amp;&amp; nums[left + 1] === nums[left]) {
          left++
        }
        while (left &lt; right &amp;&amp; nums[right - 1] === nums[right]) {
          right--
        }
        // 避免重复解之后也不要忘了移动指针，否则会死循环
        left++
        right--
      } else if (total &gt; 0) {
        right = right - 1
      } else {
        left = left + 1
      }
    }
  }
  return result
};
</code></pre>
<p>思路：<br>
三数之和，可以以第一个数为游标（固定数），排序之后向后移动，中间数Left即为 i + 1，最大数Right可暂定num.length - 1<br>
如果和大于0，说明最大数太大，Right向左偏移<br>
如果和小于0，说明中间数太小，Left向右偏移<br>
中间遇到合法的解，为了避免后面有重复的数字，需要判断，并继续偏移</p>
<h1 id="20200412">20200412</h1>
<p><strong>题型：反向遍历</strong><br>
题号：58 <a href="https://leetcode-cn.com/problems/length-of-last-word/">最后一个单词的长度</a><br>
思路：很简单，不过js的执行效率不够高，解释型语言就是这样。这边复习一下js执行的过程吧，我们都只到js是由v8引擎驱动的，v8要开始执行一段js代码，首先需要对这行js代码进行词法分析，分析每个字符的含义，然后是语法分析，分析这些字符组合在一起的含义，再然后再转成v8引擎能够识别的AST语法树，然后将其编译成字节码（字节码是在机器码上层封装的一种代码格式），然后由JIT编译器逐行执行（补充一下，当某段代码被重复执行时，v8会将其转为机器码，来提高之后的执行效率，不将所有代码转换成机器码的原因是，一行代码转成机器码可能有20行，内存占用大，所以只有部分高频使用的代码才会转成机器码）。</p>
<h1 id="20200413">20200413</h1>
<p><strong>题型：数组的深度优先遍历 | 回溯 | 全排列</strong><br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdwzljjaxsj30se0hcjsf.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
  let result = []
  let resultSet = new Set()
  handler(nums, [], result, resultSet)
  return result
};

function handler (arr, temp, result, resultSet) {
  if (!arr.length) {
    if (!resultSet.has(JSON.stringify(temp))) {
      resultSet.add(JSON.stringify(temp))
      result.push(temp)
    }
    return
  }
  for (let i = 0; i &lt; arr.length; i++) {
    let t = [...temp, arr[i]]
    let next = arr.slice(0, i).concat(arr.slice(i + 1))
    handler(next, t, result, resultSet)
  }
}
</code></pre>
<p>思路：同全排列I，这道全排列II，只是多了去重的一步，重要的是回溯的思路，为了得到全排列，必须每一位都和剩下的任意一位组合，因此回溯必不可少，回溯的过程中需要组合的元素会越来越少，每一次回溯都会取出一个元素与上一次的temp进行组合，然后从数组中刨除这个元素，开始下一轮的组合，此类组合方式也是深度优先遍历的一种，第一步会从第一位组合到最后一位比如[1,2,3,4]，第二步会从第一位到倒数第二位开始组合即[1,2,4,3]，然后[1,3,2,4]、[1,3,4,2]以此类推。</p>
<h1 id="20200414">20200414</h1>
<p><strong>题型：链表 | 栈</strong><br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdtqrmi45jj319m0oc0w2.jpg" alt="" loading="lazy"><br>
思路：关键点在于我们所需的结果和链表的存储顺序是相反的，遇到这种问题首先要想到栈，把两个链表分别推入栈中，然后再依次出栈相加，record记录下是否需要进位，很容易得到结果。</p>
<h1 id="20200415">20200415</h1>
<p><strong>题型：指针</strong><br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gduxhppkuoj30rw0p0ju1.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
  while (m &gt; 0 &amp;&amp; n &gt; 0) {
    if (nums1[m - 1] &gt; nums2[n - 1]) {
      nums1[n + m - 1] = nums1[m - 1]
      m--
    } else {
      nums1[n + m - 1] = nums2[n - 1]
      n--
    }
  }
  if (m === 0) {
    while (n &gt;= 0) {
      nums1[n - 1] = nums2[n - 1]
      n--
    }
    return nums1
  }
  return nums1
};
</code></pre>
<p>思路：解题并不难，但最优解是时间复杂度O(m+n)，空间复杂度O(1)的，从后向前双指针移动，最后补全，无需额外变量。</p>
<h1 id="20200416">20200416</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdwmdavo0uj30sg0w8774.jpg" alt="" loading="lazy"><br>
<strong>题型：递归</strong><br>
思路：全排列的变种，关键在于剪枝，及时中断，否则很容易超时</p>
<h1 id="20200417">20200417</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx049ci2tj30q00pqwi4.jpg" alt="" loading="lazy"><br>
<strong>题型：贪心算法</strong></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
  if (nums.length === 1) return true
  let max = nums[0]
  for (let i = 0; i &lt; max; i++) {
    let step = i
    while (step &lt; nums.length &amp;&amp; nums[step] !== 0) {
      step += nums[step]
      max = Math.max(max, step)
    }
    if (max &gt;= nums.length - 1) {
      return true
    }
  }
  return false
};
</code></pre>
<p>思路：每次往前跳最大格，可以到达的位置max随之增大，step起始位置也增大，如果有符合条件的跳跃方式<code>max &gt; nums.length - 1</code>，则说明条件成立。（少见的贪心算法题，关键在于遍历的条件<code>i &lt; max</code>中的max在随着贪心条件的变化而变化）</p>
<h1 id="20200418">20200418</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdzhkk26ncj30s00fs0uq.jpg" alt="" loading="lazy"><br>
<strong>题型：数学规律</strong></p>
<pre><code class="language-javascript">var nextPermutation = function(nums) {
  let i = nums.length - 2
  while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) {
    i--
  }
  // i是破坏升序的数如3，5，4，2，1中的3
  if (i &gt;= 0) {
    let j = nums.length - 1
    // 找到j遍历过的数中比破坏数大的数的位置，像是4
    while (j &gt;= i &amp;&amp; nums[j] &lt;= nums[i]) {
      j--
    }
    // 进行一次交换，得到4，5，3，2，1
    swap(nums, i, j)
  }
  // 然后要保证后面的数升序，得到下一个排列
  if (i &gt;= 0) {
    i = i + 1
    // console.log(i, nums, '-----')
    let j = nums.length - 1
    while (i &lt; j) {
      swap(nums, i, j)
      i++
      j--
    }
    return nums
  }  
  return nums.reverse()
};

function swap (nums, i, j) {
  let temp = nums[i]
  nums[i] = nums[j]
  nums[j] = temp
}
</code></pre>
<p>思路：寻找下一个排列更大的数，解法倒序遍历，先找到第一个破坏了降序的数，然后在前面的数里找到比这个数大的数对它进行替换，再把遍历过的数进行翻转，保证是<strong>下一个</strong>排列更大的数即可，最多遍历两次（每次做到这种题，就觉得对刷题的兴趣越来越不够了，这种找规律的题就算法来说并没有什么规律可言，只是数学上的一种规则，如果做过或许很快就能找到规律，没做过，可能很久也想不出来，时间花在这上面，带来的收益是成正比的吗？）</p>
<h1 id="20200419">20200419</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdzi0zimxgj30ss0i03zz.jpg" alt="" loading="lazy"><br>
<strong>题型：链表</strong></p>
<pre><code class="language-javascript">var deleteDuplicates = function(head) {
  loop(head)
  return head
};

function loop (linked) {
  if (linked &amp;&amp; linked.next) {
    if (linked.val === linked.next.val) {
      linked.next = linked.next.next
      loop(linked)
    } else {
      loop(linked.next)
    }
  }
}
</code></pre>
<p>思路：正向遍历链表好了，如果重复，则舍弃重复链，重新比较，否则继续向下遍历。</p>
<h1 id="20200420">20200420</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge0okp0hxgj30ys0u0426.jpg" alt="" loading="lazy"><br>
<strong>题型：无向图遍历</strong></p>
<pre><code class="language-javascript">/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
    let num = 0;
    if(grid &amp;&amp; grid.length) {
        const maxI = grid.length - 1, maxJ = grid[0].length - 1
        function overturn(i, j) {
            if(i &lt; 0 || j &lt; 0 || i &gt; maxI || j &gt; maxJ) return;
            if(grid[i][j] === '1') {
              // 该值周边所有相连的1都可以翻转成0看做同一个岛屿
              grid[i][j] = '0'
              overturn(i, j-1)
              overturn(i-1, j)
              overturn(i+1, j)
              overturn(i, j+1)
            }
        }
        for(let i = 0; i &lt; grid.length; i++) {
            for(let j = 0; j &lt; grid[i].length; j++) {
                if(grid[i][j] === '1') {
                    num++;
                    overturn(i, j)
                }
            }
        }
    }
    return num;
};
</code></pre>
<p>思路：找到陆地时，继续遍历其周边的陆地，如果有相连的陆地，则他们属于同一座岛屿，可以置为0，两次for循环即可，同之前做的机器人的问题，只能上下左右走一个，找准题目条件是关键，这个题还挺好玩的</p>
<h1 id="20200421">20200421</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2ytc1lucj30tw0h4q47.jpg" alt="" loading="lazy"><br>
<strong>题型：广度优先遍历</strong></p>
<pre><code class="language-javascript">var rightSideView = function(root) {
 if (!root) return []
 let queue = [root]
 let result = []
 let depth = 0
 while (queue.length) {
  let l = queue.length
  result[depth] = []
  for (let i = 0; i &lt; l; i++) {
    let temp = queue.shift()
    result[depth].push(temp.val)
    if (temp.left) queue.push(temp.left)
    if (temp.right) queue.push(temp.right)
  }
  depth++
 }
 return result.map(arr =&gt; arr.slice(-1))
};
</code></pre>
<p>思路：老题了，bfs一次取最右侧数据即可</p>
<h1 id="20200422">20200422</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge59grhyedj30uk0ren0e.jpg" alt="" loading="lazy"><br>
<strong>题型：矩阵、数学</strong></p>
<pre><code class="language-javascript">/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
  if (!matrix.length || !matrix[0].length) return []
  // right,down,left,up
  let dir = 'right'
  let il = matrix.length
  let jl = matrix[0].length
  let total = il * jl
  let center = `${Math.floor(il / 2)}${Math.floor(jl / 2)}`
  let leftL = 0
  let topL = 0
  let i = 0
  let j = 0
  let result = []
  while (result.length !== total - 1) {
    while (dir === 'right' &amp;&amp; j &lt;= jl - 1 &amp;&amp; result.length !== total - 1) {
      if (j === jl - 1) {
        topL++
        dir = 'down'
      } else {
        result.push(matrix[i][j])
        j++
      }
    }
    while (dir === 'down' &amp;&amp; i &lt;= il - 1 &amp;&amp; result.length !== total - 1) {
      if (i === il - 1) {
        jl--
        dir = 'left'
      } else {
        result.push(matrix[i][j])
        i++
      }
    }
    while (dir === 'left' &amp;&amp; j &gt;= leftL &amp;&amp; result.length !== total - 1) {
      if (j === leftL) {
        il--
        dir = 'up'
      } else {
        result.push(matrix[i][j])
        j--
      }
    }
    while (dir === 'up' &amp;&amp; i &gt;= topL &amp;&amp; result.length !== total - 1) {
      if (i === topL) {
        leftL++
        dir = 'right'
      } else {
        result.push(matrix[i][j])
        i--
      }
    }
  }
  return result.concat([matrix[i][j]])
};
</code></pre>
<p>思路：按照题意来即可，每次收窄边界，长度达到限度则已经收集完毕。</p>
<h1 id="20200423">20200423</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge59x96f87j30ua0oowgq.jpg" alt="" loading="lazy"><br>
<strong>题型：斐波那契、dp</strong><br>
思路：dp[n] = dp[n - 1] + dp[n - 2] 唯一的问题是要在循环里取模，不然最后的精度会丢失。</p>
<h1 id="20200424">20200424</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6efvradsj30u40j8acl.jpg" alt="" loading="lazy"><br>
<strong>题型：链表，双指针</strong></p>
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var getKthFromEnd = function(head, k) {
  let temp = head
  let l = getLinkedLength(temp)
  for (let i = 0; i &lt;= l - k; i++) {
    head = head.next
  }
  return head
};

function getLinkedLength (head) {
  let length = 0
  while (head &amp;&amp; head.next) {
    length++
    head = head.next
  }
  return length
}
</code></pre>
<p>思路：第一时间想到的是统计链表长度，返回l-k位置的链表就行，其实也可以不统计长度，使用快慢指针的形式，快指针先走k次，然后快慢指针一起走，快指针走到头了，慢指针所指的位置即为倒数第k个的位置。</p>
<h1 id="20200425">20200425</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge8qsj1rmmj30u80kyabm.jpg" alt="" loading="lazy"><br>
<strong>题型：hash表，桶排序</strong><br>
思路：两次遍历，进行减少遍历条件，减少哈希表大小，正常思路来即可。</p>
<h1 id="20200426">20200426</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge8r70qb9kj30tq0r8djy.jpg" alt="" loading="lazy"><br>
<strong>题型：栈和队列的应用</strong></p>
<pre><code class="language-javascript">/**
 * @param {number[]} pushed
 * @param {number[]} popped
 * @return {boolean}
 */
var validateStackSequences = function(pushed, popped) {
  let temp = []
  for (let i = 0; i &lt; pushed.length; i++) {
    temp.push(pushed[i])
    while (temp[temp.length - 1] === popped[0] &amp;&amp; popped[0] !== void 0) {
      temp.pop()
      popped.shift()
    }
  }
  while (popped.length) {
    if (temp[temp.length - 1] === popped[0]) {
      temp.pop()
      popped.shift()
    } else {
      return false
    }
  }
  return true
};
</code></pre>
<p>思路：栈底等于队列头部则出栈，出队列，若不等则继续推入栈中，最后判断出栈队列是否清空即可。</p>
<h1 id="20200427">20200427</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge9xsia6vyj30sq0ncq52.jpg" alt="" loading="lazy"><br>
<strong>题型：js的异或操作</strong></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  let result = 0
  for (let i = 0; i &lt; nums.length; i++) {
    result ^= nums[i]
  }
  return result
};
</code></pre>
<p>思路：思路新奇，不需要借助额外的空间，因为相同的元素进行异或操作一定是0，只要把所有元素进行异或，得到的值肯定就是只出现一次的那个值。</p>
<h3 id="js的位操作-与-或-非-异或-左移-右移操作">js的位操作 与、或、非、异或、左移、右移操作</h3>
<p>与：&amp;<br>
或：|<br>
非：~<br>
异或：^<br>
左移：5 &lt;&lt; 1<br>
右移：5 &gt;&gt; 1</p>
<h1 id="20200428">20200428</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gec8gwlcidj30uc0p6jub.jpg" alt="" loading="lazy"><br>
<strong>题型：快慢指针</strong></p>
<pre><code class="language-javascript">/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    let slow = n
    let fast = n
    do {
      slow = getNumT(slow)
      fast = getNumT(fast)
      fast = getNumT(fast)
    } while (slow !== fast)
    return slow === 1
};

function getNumT (n) {
  let temp = String(n).split('').map(item =&gt; Number(item))
  return temp.reduce((pre, cur) =&gt; {
    return pre + Math.pow(cur, 2)
  }, 0)
}
</code></pre>
<p>思路：<br>
思路1：就是递归，然后HashSet存储判断，但是遇到特别大的数可能会超出存储限制<br>
思路2：快慢指针，最后归于一致说明已经经过了一次循环，归于一致的值如果是1，说明是快乐数</p>
<h1 id="20200429">20200429</h1>
<p><strong>题型：双指针</strong><br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gec8o7b3zqj30u80mw0v3.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number[]}
 */
var exchange = function(nums) {
  let i = 0
  let j = nums.length - 1
  while (i &lt; j) {
    if (nums[i] % 2 === 0) {
      while (i &lt; j &amp;&amp; nums[j] % 2 === 0) {
        j--
      }
      swap(i, j, nums)
    }
    i++
  }
  return nums
};

function swap (i, j, nums) {
  let temp = nums[i]
  nums[i] = nums[j]
  nums[j] = temp
}
</code></pre>
<p>思路：一开始想的是遍历一次，造两个数组时间复杂度O(n)，空间复杂度O(n)<br>
更好的思路：双指针，数组内部交换位置，时间复杂度O(n)，空间复杂度O(1)</p>
<h1 id="20200430">20200430</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gede21uyhpj30tm0dgdh1.jpg" alt="" loading="lazy"><br>
<strong>题型：链表</strong></p>
<pre><code class="language-javascript">var mergeTwoLists = function(l1, l2) {
  if (!l1) {
    return l2
  } else if (!l2) {
    return l1
  } else if (l1.val &lt; l2.val) {
    l1.next = mergeTwoLists(l1.next, l2)
    return l1
  } else {
    l2.next = mergeTwoLists(l1, l2.next)
    return l2
  }
};
</code></pre>
<p>思路：不借助额外的空间，递归链表，当有一个链表为null时返回另一个链表接到上一个链表的尾部</p>
<h1 id="20200501">20200501</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gedxd1do64j30pw0tmgp9.jpg" alt="" loading="lazy"><br>
<strong>题型：双指针，滑动窗口，数学</strong></p>
<pre><code class="language-javascript">var lengthOfLongestSubstring = function(s) {
  let result = 0
  let begin = -1
  let end = 0
  const map = new Map()
  for (let i = 0; i &lt; s.length; i++) {
    // 碰到重复出现的字符，后面的子序列长度要和前面最大的子序列长度做对比
    if (!map.has(s[i]) || map.get(s[i]) &lt;= begin) {
      end = i
      result = Math.max(end - begin, result)
    } else {
      // 已存在，更新begin位置，为上一个出现s[i]的后一位
      begin = map.get(s[i])
    }
    // 更新begin的位置
    map.set(s[i], i)
  }
  return result
};
</code></pre>
<p>思路：记录begin和end的位置，遇到重复字符，如果重复字符已经在begin之前，则不再更新begin位置，但是需要判断当前end-begin的长度是否已经超过前面的最大子序列的长度，如果重复字符在begin之后，那么可以直接更新begin了，避免[begin, end]的区间内有重复字符。</p>
<h1 id="20200526">20200526</h1>
<p>无题<br>
<strong>插入排序</strong></p>
<pre><code class="language-javascript">function insertSort (arr) {
  for (let i = 1; i &lt; arr.length; i++) {
    let temp = arr[i] // 记录要插入的元素
    let j = i
    while (j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp) {
        arr[j] = arr[j - 1]
        j--
    }
    arr[j] = temp
  }
  return arr
}
</code></pre>
<p>思路：假设第一项已经排好序，第一项作为插入项，与前面位进行比较，如果前面位较大，则替换当前位置，每次循环都能保证到第一次不满足条件的位置，之前的数已经排好序了，最好将插入项插入到第一个不满足条件的位置即可，sort函数在长度小于10的数组时采用的就是插入排序，性能比快排和冒泡效率偏高，在10-1000位时采用的是快排，取中位数作为哨兵，大于1000位时取哨兵元素有些许不同</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[babel最佳实践[babel7.4及以上]]]></title>
        <id>https://chentianyuan.github.io/post/babel-pluginbabel-presetbabel-runtimebabel-polyfill/</id>
        <link href="https://chentianyuan.github.io/post/babel-pluginbabel-presetbabel-runtimebabel-polyfill/">
        </link>
        <updated>2020-03-26T03:00:19.000Z</updated>
        <summary type="html"><![CDATA[<p>各式各样的babel工具，babel-plugin/babel-preset/babel-runtime/babel-polyfill.....</p>
]]></summary>
        <content type="html"><![CDATA[<p>各式各样的babel工具，babel-plugin/babel-preset/babel-runtime/babel-polyfill.....</p>
<!-- more -->
<h1 id="babel配置读取">babel配置读取</h1>
<p>1、可以通过babe-cli命令行转义高级语法，命令行配置，指定文件<br>
2、加入script命令，指定babel配置文件<br>
3、通过babel-loader配置，借助webpack，打包时自动读取cwd()根目录的.babelrc或babel.config.js</p>
<h1 id="babelpreset-env">@babel/preset-env</h1>
<p>babel7的preset工具@babel/preset-env</p>
<pre><code class="language-javascript">// .babelrc
{
    &quot;presets&quot;: [
        &quot;@babel/preset-env&quot;,
        options
    ]
}
</code></pre>
<p>配置过后，babel-loader会读取该文件，并根据预设转换需要转换的高级<strong>语法</strong>，但是它并不提供高级语法如Array.prototype.includes、Array.prototype.flat的垫片。</p>
<h1 id="babelpolyfill">@babel/polyfill</h1>
<p>core-js@3的出现，替代了@babel/polyfill，配合@babel/preset-env的useBuiltlns选项，可以得到更小的代码体积</p>
<pre><code class="language-javascript">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;corejs&quot;: 3 // 如果不指定，会默认使用core-js2.x
      }
    ]
  ]
}
</code></pre>
<h1 id="babelplugin-transfrom-runtime">@babel/plugin-transfrom-runtime</h1>
<p>上面的配置可以达到转义的功能，但是看一下输出的代码</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

require(&quot;core-js/modules/es.array.from&quot;);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }

var Parent = function Parent() {
  _classCallCheck(this, Parent);
};

Array.from([])
</code></pre>
<p>上面编译的代码有两个问题<br>
1、helper重复注入<br>
2、全局环境污染</p>
<h2 id="重复注入">重复注入</h2>
<p>babel-runtime会在每个文件，使用到class Xxx {} 的地方提供一个helper，如果class很多，会使得单文件体积变大。然后就到了@babel/plugin-transfrom-runtime出场的时候了</p>
<pre><code class="language-javascript">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;corejs&quot;: 3
      }
    ]
  ],
  &quot;plugins&quot;: [
    &quot;@babel/plugin-transform-runtime&quot;
  ]
}
</code></pre>
<p>然后_classCallCheck就会作为一个模块被生成，而不是每次都注入一个_classCallCheck函数了。</p>
<h2 id="全局环境污染">全局环境污染</h2>
<p>可以看到<code>require(&quot;core-js/modules/es.array.from&quot;);</code>直接把Array的from函数给顶掉了，如果babel团队更新不及时，而js引擎换了对from的解析规则，那么真实的Array.from方法就被替换了，所以为了避免这种情况发生，需要安装@babel/runtime-corejs3</p>
<pre><code class="language-javascript">{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;,
    {
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;corejs&quot;: 3
    }
  ],
  &quot;plugins&quot;: [
    [
      &quot;@babel/transform-runtime&quot;,
      {
        &quot;corejs&quot;: 3
      }
    ]
  ]
}
</code></pre>
<p>输出的代码会实现一个_from方法，然后将代码中所有的Array.from替换为Array._from，避免了在兼容高级语法的机型上，语法被污染的情况。上面也是babel7语法转换最佳配置，最后需要安装的插件有</p>
<pre><code class="language-bash">npm i @babel/preset-env corejs@3 @babel/transfrom-runtime @babel/runtime-corejs3 -D
</code></pre>
<h2 id="总结">总结</h2>
<h3 id="babelpolyfill-和-babelruntime">@babel/polyfill 和 @babel/runtime</h3>
<p>两个都可以提供es2015的环境，为Array.prototype.reduce之类的方法提供垫片，区别在于<br>
@babel/polyfill 是通过在Array.prototype上添加了一个自己的reduce方法，会覆盖原方法<br>
而@babel/runtime是通过引入一个_reduce方法，然后将项目中的reduce方法替换成_reduce，减少了全局污染</p>
<h3 id="babelplugin-transfrom-runtime-和-babelruntime">@babel/plugin-transfrom-runtime 和 @babel/runtime</h3>
<pre><code class="language-bash">npm install --save-dev @babel/plugin-transform-runtime
npm install --save @babel/runtime
</code></pre>
<p>plugin-transform-runtime可以和polyfill或者runtime配合，它是用来分析文件需要的垫片，自动从polyfill或者runtime中获取并加入的<br>
@babel/runtime 用来在生产环境中提供垫片<br>
撒花✿✿ヽ(°▽°)ノ✿</p>
]]></content>
    </entry>
</feed>