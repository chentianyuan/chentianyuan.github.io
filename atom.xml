<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chentianyuan.github.io</id>
    <title>City Corner</title>
    <updated>2020-04-30T16:14:32.034Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chentianyuan.github.io"/>
    <link rel="self" href="https://chentianyuan.github.io/atom.xml"/>
    <subtitle>脚踏实地 仰望星空</subtitle>
    <logo>https://chentianyuan.github.io/images/avatar.png</logo>
    <icon>https://chentianyuan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, City Corner</rights>
    <entry>
        <title type="html"><![CDATA[页面适配后的真相]]></title>
        <id>https://chentianyuan.github.io/post/ni-zhi-dao-ji-chong-ye-mian-gua-pei-fang-an/</id>
        <link href="https://chentianyuan.github.io/post/ni-zhi-dao-ji-chong-ye-mian-gua-pei-fang-an/">
        </link>
        <updated>2020-04-24T10:44:22.000Z</updated>
        <summary type="html"><![CDATA[<p>市场上的移动端产品层出不穷，如何一套代码应对不同分辨率的手机？</p>
]]></summary>
        <content type="html"><![CDATA[<p>市场上的移动端产品层出不穷，如何一套代码应对不同分辨率的手机？</p>
<!-- more -->
<h1 id="移动端的适配方案">移动端的适配方案</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6fpqm6m2j31ik0r44n5.jpg" alt="" loading="lazy"><br>
电影天堂的页面并没有做适配，但是放到移动端访问，页面进行了自动的缩放，包括字体，但是设置同样的字体时会员页的字体并没有被缩放？真相是？</p>
<h2 id="移动端的三种像素">移动端的三种像素</h2>
<p>移动端最开始其实只有两种像素</p>
<h3 id="物理像素device-pixels">物理像素（device pixels）</h3>
<p>指屏幕的物理像素，又叫设备像素，任何设备的物理像素都是固定的。</p>
<h3 id="css像素css-pixels">css像素（css pixels）</h3>
<p>这个比较好理解，就是我们常写的100px，200px代码中所指的像素，它和物理像素之间的换算取决于屏幕的特性（是否为高密度屏），比如，在普通屏幕和苹果的视网膜屏幕上，2px所代表的物理像素是不同的<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6furft4vj30eb07ymxo.jpg" alt="" loading="lazy"><br>
普通屏幕2px等于2个物理像素，而视网膜屏2px等于8个物理像素，如果用户进行手动放大，一个px还会相当于更多个物理像素。</p>
<h3 id="设备像素比dpr">设备像素比（dpr）</h3>
<p>又叫dpr，apple的dpr等于2，因为dpr = 物理像素 和 设备独立像素（也就是css像素）的比值。</p>
<h2 id="屏幕的三种视口">屏幕的三种视口</h2>
<h3 id="布局视口-和-视觉视口">布局视口 和 视觉视口</h3>
<h4 id="布局视口">布局视口</h4>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6g0p4q8sj309c07xdg2.jpg" alt="" loading="lazy"><br>
一般移动设备的浏览器都默认设置了一个 viewport 元标签，定义一个虚拟的布局视口（layout viewport）早期为了兼容pc端的网页，屏幕厂商都把布局视口统一设置为980px，我们可以通过<br>
<code>docuemnt.documentElement.clientWidth</code> 来获取</p>
<h4 id="视觉视口">视觉视口</h4>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6g1en1tgj308z084q36.jpg" alt="" loading="lazy"><br>
视觉视口就是用户可以看到的真实屏幕的视口大小<br>
当视觉视口小于布局视口时，屏幕会进行一个自动的缩放，来保证大的布局也能在页面上完全显示。<br>
缩放比例 = 布局视口 / 视觉视口<br>
所以当我们在移动端看电影天堂的页面，是经过了自动缩放的，如果设置<code>&lt;meta name=&quot;view-port&quot; content=&quot;375&quot; &gt;</code>会发现，字体大小恢复了，页面需要滚动来查看视觉视口外的内容</p>
<h3 id="理想视口">理想视口</h3>
<p>慢慢的，浏览器厂商发现布局视口的默认宽度980px并不是一个理想的宽度，因此浏览器厂商引入了理想视口的概念，它对设备而言是最理想的布局视口尺寸。显示在理想视口中的网站具有最理想的宽度，用户无需进行缩放。理想视口的值其实就是屏幕分辨率（对应的像素叫设备逻辑像素）的值（不等同于视觉视口，视觉视口会小于或等于屏幕分辨率）<br>
<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code><br>
这行代码可以保证理想视口和布局视口一致。<br>
移动端我们常用视口原标签来保证我们的网页不会因为布局视口或者用户的手指操作而缩放<br>
<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1&quot;&gt;</code></p>
<h2 id="倍图">倍图</h2>
<p>以下是常见的设备像素比<br>
普通密度桌面显示屏：devicePixelRatio = 1<br>
高密度桌面显示屏(Mac Retina)：devicePixelRatio = 2<br>
主流手机显示屏：devicePixelRatio = 2 or 3<br>
也就是之前说的dpr，在不同的显示屏下，设备像素比不同，如果统一用2倍图（宽高100的图，分辨率是200*200）@2x，在普通显示屏会有色彩聚集的感觉，因为用1个物理像素来描绘4个图片像素，但是在设备像素比为3的显示屏，相当于用9个物理像素描绘4个图片像素，图片会有失真的感觉，因此这时就要使用3倍图@3x甚至@4x来避免图片的失真。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[秘技：图片领域]]></title>
        <id>https://chentianyuan.github.io/post/mi-ji-tu-pian-ling-yu/</id>
        <link href="https://chentianyuan.github.io/post/mi-ji-tu-pian-ling-yu/">
        </link>
        <updated>2020-04-24T06:01:59.000Z</updated>
        <summary type="html"><![CDATA[<p>万物皆二进制，图片的<br>
jpeg/bmp/png/webp</p>
]]></summary>
        <content type="html"><![CDATA[<p>万物皆二进制，图片的<br>
jpeg/bmp/png/webp</p>
<!-- more -->
<h1 id="图片属性要素">图片属性要素</h1>
<p>一张图片的组成部分，通常有</p>
<ul>
<li>图片格式 （jpeg/bmp/png/webp）</li>
<li>图片大小（大小和尺寸是不一样的）</li>
<li>像素（也叫尺寸，像素可以理解为像素点，无论图片怎么放大缩小，图片的像素点是不变的）</li>
<li>dpi（每英寸的像素，也叫扫描精度，web上大部分的图片都是72dpi，也就是每英寸72个像素。但是打印照片时，比如一张4<em>6英寸的照片，扫描精度必须大于300dpi，那么文件的尺寸应该是（4*300）</em>（6*300）= 1200 * 1800 像素）</li>
<li>颜色模式（RGB，RGBA...）<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge4xioff62j30m80jejti.jpg" alt="图片示例" loading="lazy"><br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge4x40cimoj30hs0emmy9.jpg" alt="detail" loading="lazy"></li>
</ul>
<h1 id="前端应用">前端应用</h1>
<h3 id="1-gif埋点">1、gif埋点</h3>
<p>百度统计的埋点方式是在首屏引入一个三方的js，然后这个三方的js会种下一个三方的uuid cookie在他们的域下，标识一个用户，每到一个页面会new一个image对象，请求这张图片时会带上前面的cookie，并带上页面数据。那么为什么要使用gif来上报埋点参数呢？<br>
大致原因如下：</p>
<ul>
<li>image.src天然支持跨域</li>
<li>图片请求优先级低，不占用ajax请求限额，不阻塞页面加载</li>
<li>相对ajax GET请求较为轻量</li>
<li>1x1像素是最小的合法图片，而且图片最好是透明的，不影响页面显示效果，而jpeg是不支持透明色的，jpeg的颜色模式是rgb可以直接排除，剩下bmp，png，gif。因为任何一张图片二进制编码都有一些必要的结构体标头，来标识图片信息，最后通过比对，同等条件下gif的必须标头仅43个字节，png67个，bmp74个，因此gif才是最佳选择</li>
</ul>
<h3 id="2-图片压缩">2、图片压缩</h3>
<p>在使用图片时，我们常常要对图片进行一次压缩，不同的图片类型，压缩方式，都会影响图片的压缩效果。</p>
<h4 id="png">png</h4>
<p>png图片颜色模式rgba，web应用中通常使用的是png8，也就是8位深度的png图片，位深度是每个像素所需要的像素大小。<br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge4yvad06ej30sb099n03.jpg" alt="" loading="lazy"><br>
位深度越大，图片的细腻程度越高，当位深度是1，那么每个像素都由0和1来表示，那么也就只能表示黑白的图片了<br>
不同的位数其像素计算的规则不同<br>
8位：  2^8 = 2^2(B) 2^3(G) 2^3(R) = 256  (256色)    可以总共显示256种颜色<br>
16位：2^16 = 2^5(B) 2^6(G) 2^5(R) =  65536    可以总共显示65536种颜色<br>
24位：2^24 = 2^8(B) 2^8(G) 2^8(R) =  16777216    可以总共显示16777216种颜色<br>
32位：Alpha透明度 + 24位<br>
用图片像素乘上图片位数即为这张原始图片所占的字节数，当然可以经过一层压缩。<br>
png的压缩属于无损数据压缩，在保持图片质量的同时，还减少了图片的体积，8位支持alpha透明（只有透明和不透明），而32位有2^8种透明程度。png现常用于web上的logo，icon等图片中</p>
<h4 id="jpegjpg">jpeg&amp;jpg</h4>
<p>jpeg其实就是jpg，在web应用中不太常见，采用的是有损压缩方式，可能会导致图片失真，颜色规则rgb，不支持透明色，位深度现在也只有24位，但是相比于png-24，jpeg的无损压缩可以移除人的肉眼无法识别的图片细节，对色彩丰富的图片有更好的压缩效果</p>
<h4 id="bmp">bmp</h4>
<p>bmp原始图片，通常不采用压缩，图片质量也是最高的</p>
<h4 id="webp">webp</h4>
<p>webp支持有损和无损压缩两种压缩形式，将jpeg和png转为webp之后，实际体积会大幅缩小，webp通过分块和帧内预测的方法，对原有图片进行处理，比jpeg上使用的Huffman encoding表现得更为出色，唯一的缺点就是浏览器兼容性不好。</p>
<h4 id="通用图片选择方法">通用图片选择方法</h4>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge4zjpeug1j30gt09njsc.jpg" alt="" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<p>前端在埋点上对图片的选择缘由<br>
前端常见图片格式的分别<br>
现在公司使用的kano系统应该是根据ua来判断当前浏览器对webp的支持程度，统一返回webp的图片了~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一天一道算法题系列（4.10-5.10）]]></title>
        <id>https://chentianyuan.github.io/post/yi-tian-yi-dao-suan-fa-ti-xi-lie-410-510/</id>
        <link href="https://chentianyuan.github.io/post/yi-tian-yi-dao-suan-fa-ti-xi-lie-410-510/">
        </link>
        <updated>2020-04-10T15:59:29.000Z</updated>
        <summary type="html"><![CDATA[<p>第二个30天，士兵们，新一轮的战斗开始了</p>
]]></summary>
        <content type="html"><![CDATA[<p>第二个30天，士兵们，新一轮的战斗开始了</p>
<!-- more -->
<h1 id="20200410">20200410</h1>
<p><strong>题型：双指针 | 库函数</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdp4dnxb14j30uk0u0myh.jpg" alt="" loading="lazy"><br>
思路：<br>
1、统计每个单词的左右边界，i，j最后反向插入即可<br>
2、利用库函数split，过滤空格，reverse反正得到结果</p>
<h1 id="20200411">20200411</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqal0bkyoj319k0nu3z8.jpg" alt="" loading="lazy"><br>
<strong>题型：双指针，数学</strong></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  let result = []
  if (nums.length &lt; 3) return result
  // 顺序排序
  nums = nums.sort((a, b) =&gt; a - b)
  for (let i = 0; i &lt; nums.length; i++) {
    // 首个元素大于0可以不用再比了
    if (nums[i] &gt; 0) return result
    // 和上个元素相同，避免重复解
    if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) {
      continue
    }
    let left = i + 1
    let right = nums.length - 1
    while (left &lt; right) {
      var total = nums[i] + nums[left] + nums[right]
      if (total === 0) {
        // 先承认该数
        result.push([nums[i], nums[left], nums[right]])
        // 避免重复解，只需要在得到解之后，遇到相同数的时候继续向后移动即可避免重复解
        while (left &lt; right &amp;&amp; nums[left + 1] === nums[left]) {
          left++
        }
        while (left &lt; right &amp;&amp; nums[right - 1] === nums[right]) {
          right--
        }
        // 避免重复解之后也不要忘了移动指针，否则会死循环
        left++
        right--
      } else if (total &gt; 0) {
        right = right - 1
      } else {
        left = left + 1
      }
    }
  }
  return result
};
</code></pre>
<p>思路：<br>
三数之和，可以以第一个数为游标（固定数），排序之后向后移动，中间数Left即为 i + 1，最大数Right可暂定num.length - 1<br>
如果和大于0，说明最大数太大，Right向左偏移<br>
如果和小于0，说明中间数太小，Left向右偏移<br>
中间遇到合法的解，为了避免后面有重复的数字，需要判断，并继续偏移</p>
<h1 id="20200412">20200412</h1>
<p><strong>题型：反向遍历</strong><br>
题号：58 <a href="https://leetcode-cn.com/problems/length-of-last-word/">最后一个单词的长度</a><br>
思路：很简单，不过js的执行效率不够高，解释型语言就是这样。这边复习一下js执行的过程吧，我们都只到js是由v8引擎驱动的，v8要开始执行一段js代码，首先需要对这行js代码进行词法分析，分析每个字符的含义，然后是语法分析，分析这些字符组合在一起的含义，再然后再转成v8引擎能够识别的AST语法树，然后将其编译成字节码（字节码是在机器码上层封装的一种代码格式），然后由JIT编译器逐行执行（补充一下，当某段代码被重复执行时，v8会将其转为机器码，来提高之后的执行效率，不将所有代码转换成机器码的原因是，一行代码转成机器码可能有20行，内存占用大，所以只有部分高频使用的代码才会转成机器码）。</p>
<h1 id="20200413">20200413</h1>
<p><strong>题型：数组的深度优先遍历 | 回溯 | 全排列</strong><br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdwzljjaxsj30se0hcjsf.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
  let result = []
  let resultSet = new Set()
  handler(nums, [], result, resultSet)
  return result
};

function handler (arr, temp, result, resultSet) {
  if (!arr.length) {
    if (!resultSet.has(JSON.stringify(temp))) {
      resultSet.add(JSON.stringify(temp))
      result.push(temp)
    }
    return
  }
  for (let i = 0; i &lt; arr.length; i++) {
    let t = [...temp, arr[i]]
    let next = arr.slice(0, i).concat(arr.slice(i + 1))
    handler(next, t, result, resultSet)
  }
}
</code></pre>
<p>思路：同全排列I，这道全排列II，只是多了去重的一步，重要的是回溯的思路，为了得到全排列，必须每一位都和剩下的任意一位组合，因此回溯必不可少，回溯的过程中需要组合的元素会越来越少，每一次回溯都会取出一个元素与上一次的temp进行组合，然后从数组中刨除这个元素，开始下一轮的组合，此类组合方式也是深度优先遍历的一种，第一步会从第一位组合到最后一位比如[1,2,3,4]，第二步会从第一位到倒数第二位开始组合即[1,2,4,3]，然后[1,3,2,4]、[1,3,4,2]以此类推。</p>
<h1 id="20200414">20200414</h1>
<p><strong>题型：链表 | 栈</strong><br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdtqrmi45jj319m0oc0w2.jpg" alt="" loading="lazy"><br>
思路：关键点在于我们所需的结果和链表的存储顺序是相反的，遇到这种问题首先要想到栈，把两个链表分别推入栈中，然后再依次出栈相加，record记录下是否需要进位，很容易得到结果。</p>
<h1 id="20200415">20200415</h1>
<p><strong>题型：指针</strong><br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gduxhppkuoj30rw0p0ju1.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
  while (m &gt; 0 &amp;&amp; n &gt; 0) {
    if (nums1[m - 1] &gt; nums2[n - 1]) {
      nums1[n + m - 1] = nums1[m - 1]
      m--
    } else {
      nums1[n + m - 1] = nums2[n - 1]
      n--
    }
  }
  if (m === 0) {
    while (n &gt;= 0) {
      nums1[n - 1] = nums2[n - 1]
      n--
    }
    return nums1
  }
  return nums1
};
</code></pre>
<p>思路：解题并不难，但最优解是时间复杂度O(m+n)，空间复杂度O(1)的，从后向前双指针移动，最后补全，无需额外变量。</p>
<h1 id="20200416">20200416</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdwmdavo0uj30sg0w8774.jpg" alt="" loading="lazy"><br>
<strong>题型：递归</strong><br>
思路：全排列的变种，关键在于剪枝，及时中断，否则很容易超时</p>
<h1 id="20200417">20200417</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx049ci2tj30q00pqwi4.jpg" alt="" loading="lazy"><br>
<strong>题型：贪心算法</strong></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
  if (nums.length === 1) return true
  let max = nums[0]
  for (let i = 0; i &lt; max; i++) {
    let step = i
    while (step &lt; nums.length &amp;&amp; nums[step] !== 0) {
      step += nums[step]
      max = Math.max(max, step)
    }
    if (max &gt;= nums.length - 1) {
      return true
    }
  }
  return false
};
</code></pre>
<p>思路：每次往前跳最大格，可以到达的位置max随之增大，step起始位置也增大，如果有符合条件的跳跃方式<code>max &gt; nums.length - 1</code>，则说明条件成立。（少见的贪心算法题，关键在于遍历的条件<code>i &lt; max</code>中的max在随着贪心条件的变化而变化）</p>
<h1 id="20200418">20200418</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdzhkk26ncj30s00fs0uq.jpg" alt="" loading="lazy"><br>
<strong>题型：数学规律</strong></p>
<pre><code class="language-javascript">var nextPermutation = function(nums) {
  let i = nums.length - 2
  while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) {
    i--
  }
  // i是破坏升序的数如3，5，4，2，1中的3
  if (i &gt;= 0) {
    let j = nums.length - 1
    // 找到j遍历过的数中比破坏数大的数的位置，像是4
    while (j &gt;= i &amp;&amp; nums[j] &lt;= nums[i]) {
      j--
    }
    // 进行一次交换，得到4，5，3，2，1
    swap(nums, i, j)
  }
  // 然后要保证后面的数升序，得到下一个排列
  if (i &gt;= 0) {
    i = i + 1
    // console.log(i, nums, '-----')
    let j = nums.length - 1
    while (i &lt; j) {
      swap(nums, i, j)
      i++
      j--
    }
    return nums
  }  
  return nums.reverse()
};

function swap (nums, i, j) {
  let temp = nums[i]
  nums[i] = nums[j]
  nums[j] = temp
}
</code></pre>
<p>思路：寻找下一个排列更大的数，解法倒序遍历，先找到第一个破坏了降序的数，然后在前面的数里找到比这个数大的数对它进行替换，再把遍历过的数进行翻转，保证是<strong>下一个</strong>排列更大的数即可，最多遍历两次（每次做到这种题，就觉得对刷题的兴趣越来越不够了，这种找规律的题就算法来说并没有什么规律可言，只是数学上的一种规则，如果做过或许很快就能找到规律，没做过，可能很久也想不出来，时间花在这上面，带来的收益是成正比的吗？）</p>
<h1 id="20200419">20200419</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdzi0zimxgj30ss0i03zz.jpg" alt="" loading="lazy"><br>
<strong>题型：链表</strong></p>
<pre><code class="language-javascript">var deleteDuplicates = function(head) {
  loop(head)
  return head
};

function loop (linked) {
  if (linked &amp;&amp; linked.next) {
    if (linked.val === linked.next.val) {
      linked.next = linked.next.next
      loop(linked)
    } else {
      loop(linked.next)
    }
  }
}
</code></pre>
<p>思路：正向遍历链表好了，如果重复，则舍弃重复链，重新比较，否则继续向下遍历。</p>
<h1 id="20200420">20200420</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge0okp0hxgj30ys0u0426.jpg" alt="" loading="lazy"><br>
<strong>题型：无向图遍历</strong></p>
<pre><code class="language-javascript">/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
    let num = 0;
    if(grid &amp;&amp; grid.length) {
        const maxI = grid.length - 1, maxJ = grid[0].length - 1
        function overturn(i, j) {
            if(i &lt; 0 || j &lt; 0 || i &gt; maxI || j &gt; maxJ) return;
            if(grid[i][j] === '1') {
              // 该值周边所有相连的1都可以翻转成0看做同一个岛屿
              grid[i][j] = '0'
              overturn(i, j-1)
              overturn(i-1, j)
              overturn(i+1, j)
              overturn(i, j+1)
            }
        }
        for(let i = 0; i &lt; grid.length; i++) {
            for(let j = 0; j &lt; grid[i].length; j++) {
                if(grid[i][j] === '1') {
                    num++;
                    overturn(i, j)
                }
            }
        }
    }
    return num;
};
</code></pre>
<p>思路：找到陆地时，继续遍历其周边的陆地，如果有相连的陆地，则他们属于同一座岛屿，可以置为0，两次for循环即可，同之前做的机器人的问题，只能上下左右走一个，找准题目条件是关键，这个题还挺好玩的</p>
<h1 id="20200421">20200421</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2ytc1lucj30tw0h4q47.jpg" alt="" loading="lazy"><br>
<strong>题型：广度优先遍历</strong></p>
<pre><code class="language-javascript">var rightSideView = function(root) {
 if (!root) return []
 let queue = [root]
 let result = []
 let depth = 0
 while (queue.length) {
  let l = queue.length
  result[depth] = []
  for (let i = 0; i &lt; l; i++) {
    let temp = queue.shift()
    result[depth].push(temp.val)
    if (temp.left) queue.push(temp.left)
    if (temp.right) queue.push(temp.right)
  }
  depth++
 }
 return result.map(arr =&gt; arr.slice(-1))
};
</code></pre>
<p>思路：老题了，bfs一次取最右侧数据即可</p>
<h1 id="20200422">20200422</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge59grhyedj30uk0ren0e.jpg" alt="" loading="lazy"><br>
<strong>题型：矩阵、数学</strong></p>
<pre><code class="language-javascript">/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
  if (!matrix.length || !matrix[0].length) return []
  // right,down,left,up
  let dir = 'right'
  let il = matrix.length
  let jl = matrix[0].length
  let total = il * jl
  let center = `${Math.floor(il / 2)}${Math.floor(jl / 2)}`
  let leftL = 0
  let topL = 0
  let i = 0
  let j = 0
  let result = []
  while (result.length !== total - 1) {
    while (dir === 'right' &amp;&amp; j &lt;= jl - 1 &amp;&amp; result.length !== total - 1) {
      if (j === jl - 1) {
        topL++
        dir = 'down'
      } else {
        result.push(matrix[i][j])
        j++
      }
    }
    while (dir === 'down' &amp;&amp; i &lt;= il - 1 &amp;&amp; result.length !== total - 1) {
      if (i === il - 1) {
        jl--
        dir = 'left'
      } else {
        result.push(matrix[i][j])
        i++
      }
    }
    while (dir === 'left' &amp;&amp; j &gt;= leftL &amp;&amp; result.length !== total - 1) {
      if (j === leftL) {
        il--
        dir = 'up'
      } else {
        result.push(matrix[i][j])
        j--
      }
    }
    while (dir === 'up' &amp;&amp; i &gt;= topL &amp;&amp; result.length !== total - 1) {
      if (i === topL) {
        leftL++
        dir = 'right'
      } else {
        result.push(matrix[i][j])
        i--
      }
    }
  }
  return result.concat([matrix[i][j]])
};
</code></pre>
<p>思路：按照题意来即可，每次收窄边界，长度达到限度则已经收集完毕。</p>
<h1 id="20200423">20200423</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge59x96f87j30ua0oowgq.jpg" alt="" loading="lazy"><br>
<strong>题型：斐波那契、dp</strong><br>
思路：dp[n] = dp[n - 1] + dp[n - 2] 唯一的问题是要在循环里取模，不然最后的精度会丢失。</p>
<h1 id="20200424">20200424</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6efvradsj30u40j8acl.jpg" alt="" loading="lazy"><br>
<strong>题型：链表，双指针</strong></p>
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var getKthFromEnd = function(head, k) {
  let temp = head
  let l = getLinkedLength(temp)
  for (let i = 0; i &lt;= l - k; i++) {
    head = head.next
  }
  return head
};

function getLinkedLength (head) {
  let length = 0
  while (head &amp;&amp; head.next) {
    length++
    head = head.next
  }
  return length
}
</code></pre>
<p>思路：第一时间想到的是统计链表长度，返回l-k位置的链表就行，其实也可以不统计长度，使用快慢指针的形式，快指针先走k次，然后快慢指针一起走，快指针走到头了，慢指针所指的位置即为倒数第k个的位置。</p>
<h1 id="20200425">20200425</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge8qsj1rmmj30u80kyabm.jpg" alt="" loading="lazy"><br>
<strong>题型：hash表，桶排序</strong><br>
思路：两次遍历，进行减少遍历条件，减少哈希表大小，正常思路来即可。</p>
<h1 id="20200426">20200426</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge8r70qb9kj30tq0r8djy.jpg" alt="" loading="lazy"><br>
<strong>题型：栈和队列的应用</strong></p>
<pre><code class="language-javascript">/**
 * @param {number[]} pushed
 * @param {number[]} popped
 * @return {boolean}
 */
var validateStackSequences = function(pushed, popped) {
  let temp = []
  for (let i = 0; i &lt; pushed.length; i++) {
    temp.push(pushed[i])
    while (temp[temp.length - 1] === popped[0] &amp;&amp; popped[0] !== void 0) {
      temp.pop()
      popped.shift()
    }
  }
  while (popped.length) {
    if (temp[temp.length - 1] === popped[0]) {
      temp.pop()
      popped.shift()
    } else {
      return false
    }
  }
  return true
};
</code></pre>
<p>思路：栈底等于队列头部则出栈，出队列，若不等则继续推入栈中，最后判断出栈队列是否清空即可。</p>
<h1 id="20200427">20200427</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge9xsia6vyj30sq0ncq52.jpg" alt="" loading="lazy"><br>
<strong>题型：js的异或操作</strong></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  let result = 0
  for (let i = 0; i &lt; nums.length; i++) {
    result ^= nums[i]
  }
  return result
};
</code></pre>
<p>思路：思路新奇，不需要借助额外的空间，因为相同的元素进行异或操作一定是0，只要把所有元素进行异或，得到的值肯定就是只出现一次的那个值。</p>
<h3 id="js的位操作-与-或-非-异或-左移-右移操作">js的位操作 与、或、非、异或、左移、右移操作</h3>
<p>与：&amp;<br>
或：|<br>
非：~<br>
异或：^<br>
左移：5 &lt;&lt; 1<br>
右移：5 &gt;&gt; 1</p>
<h1 id="20200428">20200428</h1>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gec8gwlcidj30uc0p6jub.jpg" alt="" loading="lazy"><br>
<strong>题型：快慢指针</strong></p>
<pre><code class="language-javascript">/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    let slow = n
    let fast = n
    do {
      slow = getNumT(slow)
      fast = getNumT(fast)
      fast = getNumT(fast)
    } while (slow !== fast)
    return slow === 1
};

function getNumT (n) {
  let temp = String(n).split('').map(item =&gt; Number(item))
  return temp.reduce((pre, cur) =&gt; {
    return pre + Math.pow(cur, 2)
  }, 0)
}
</code></pre>
<p>思路：<br>
思路1：就是递归，然后HashSet存储判断，但是遇到特别大的数可能会超出存储限制<br>
思路2：快慢指针，最后归于一致说明已经经过了一次循环，归于一致的值如果是1，说明是快乐数</p>
<h1 id="20200429">20200429</h1>
<p><strong>题型：双指针</strong><br>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gec8o7b3zqj30u80mw0v3.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number[]}
 */
var exchange = function(nums) {
  let i = 0
  let j = nums.length - 1
  while (i &lt; j) {
    if (nums[i] % 2 === 0) {
      while (i &lt; j &amp;&amp; nums[j] % 2 === 0) {
        j--
      }
      swap(i, j, nums)
    }
    i++
  }
  return nums
};

function swap (i, j, nums) {
  let temp = nums[i]
  nums[i] = nums[j]
  nums[j] = temp
}
</code></pre>
<p>思路：一开始想的是遍历一次，造两个数组时间复杂度O(n)，空间复杂度O(n)<br>
更好的思路：双指针，数组内部交换位置，时间复杂度O(n)，空间复杂度O(1)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[babel最佳实践[babel7.4及以上]]]></title>
        <id>https://chentianyuan.github.io/post/babel-pluginbabel-presetbabel-runtimebabel-polyfill/</id>
        <link href="https://chentianyuan.github.io/post/babel-pluginbabel-presetbabel-runtimebabel-polyfill/">
        </link>
        <updated>2020-03-26T03:00:19.000Z</updated>
        <summary type="html"><![CDATA[<p>各式各样的babel工具，babel-plugin/babel-preset/babel-runtime/babel-polyfill.....</p>
]]></summary>
        <content type="html"><![CDATA[<p>各式各样的babel工具，babel-plugin/babel-preset/babel-runtime/babel-polyfill.....</p>
<!-- more -->
<h1 id="babel配置读取">babel配置读取</h1>
<p>1、可以通过babe-cli命令行转义高级语法，命令行配置，指定文件<br>
2、加入script命令，指定babel配置文件<br>
3、通过babel-loader配置，借助webpack，打包时自动读取cwd()根目录的.babelrc或babel.config.js</p>
<h1 id="babelpreset-env">@babel/preset-env</h1>
<p>babel7的preset工具@babel/preset-env</p>
<pre><code class="language-javascript">// .babelrc
{
    &quot;presets&quot;: [
        &quot;@babel/preset-env&quot;,
        options
    ]
}
</code></pre>
<p>配置过后，babel-loader会读取该文件，并根据预设转换需要转换的高级<strong>语法</strong>，但是它并不提供高级语法如Array.prototype.includes、Array.prototype.flat的垫片。</p>
<h1 id="babelpolyfill">@babel/polyfill</h1>
<p>core-js@3的出现，替代了@babel/polyfill，配合@babel/preset-env的useBuiltlns选项，可以得到更小的代码体积</p>
<pre><code class="language-javascript">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;corejs&quot;: 3 // 如果不指定，会默认使用core-js2.x
      }
    ]
  ]
}
</code></pre>
<h1 id="babelplugin-transfrom-runtime">@babel/plugin-transfrom-runtime</h1>
<p>上面的配置可以达到转义的功能，但是看一下输出的代码</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

require(&quot;core-js/modules/es.array.from&quot;);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }

var Parent = function Parent() {
  _classCallCheck(this, Parent);
};

Array.from([])
</code></pre>
<p>上面编译的代码有两个问题<br>
1、helper重复注入<br>
2、全局环境污染</p>
<h2 id="重复注入">重复注入</h2>
<p>babel-runtime会在每个文件，使用到class Xxx {} 的地方提供一个helper，如果class很多，会使得单文件体积变大。然后就到了@babel/plugin-transfrom-runtime出场的时候了</p>
<pre><code class="language-javascript">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;corejs&quot;: 3
      }
    ]
  ],
  &quot;plugins&quot;: [
    &quot;@babel/plugin-transform-runtime&quot;
  ]
}
</code></pre>
<p>然后_classCallCheck就会作为一个模块被生成，而不是每次都注入一个_classCallCheck函数了。</p>
<h2 id="全局环境污染">全局环境污染</h2>
<p>可以看到<code>require(&quot;core-js/modules/es.array.from&quot;);</code>直接把Array的from函数给顶掉了，如果babel团队更新不及时，而js引擎换了对from的解析规则，那么真实的Array.from方法就被替换了，所以为了避免这种情况发生，需要安装@babel/runtime-corejs3</p>
<pre><code class="language-javascript">{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;,
    {
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;corejs&quot;: 3
    }
  ],
  &quot;plugins&quot;: [
    [
      &quot;@babel/transform-runtime&quot;,
      {
        &quot;corejs&quot;: 3
      }
    ]
  ]
}
</code></pre>
<p>输出的代码会实现一个_from方法，然后将代码中所有的Array.from替换为Array._from，避免了在兼容高级语法的机型上，语法被污染的情况。上面也是babel7语法转换最佳配置，最后需要安装的插件有</p>
<pre><code class="language-bash">npm i @babel/preset-env corejs@3 @babel/transfrom-runtime @babel/runtime-corejs3 -D
</code></pre>
<h2 id="总结">总结</h2>
<h3 id="babelpolyfill-和-babelruntime">@babel/polyfill 和 @babel/runtime</h3>
<p>两个都可以提供es2015的环境，为Array.prototype.reduce之类的方法提供垫片，区别在于<br>
@babel/polyfill 是通过在Array.prototype上添加了一个自己的reduce方法，会覆盖原方法<br>
而@babel/runtime是通过引入一个_reduce方法，然后将项目中的reduce方法替换成_reduce，减少了全局污染</p>
<h3 id="babelplugin-transfrom-runtime-和-babelruntime">@babel/plugin-transfrom-runtime 和 @babel/runtime</h3>
<pre><code class="language-bash">npm install --save-dev @babel/plugin-transform-runtime
npm install --save @babel/runtime
</code></pre>
<p>plugin-transform-runtime可以和polyfill或者runtime配合，它是用来分析文件需要的垫片，自动从polyfill或者runtime中获取并加入的<br>
@babel/runtime 用来在生产环境中提供垫片<br>
撒花✿✿ヽ(°▽°)ノ✿</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一天一道算法题系列（3.9-4.9）]]></title>
        <id>https://chentianyuan.github.io/post/yi-tian-yi-dao-suan-fa-ti-xi-lie/</id>
        <link href="https://chentianyuan.github.io/post/yi-tian-yi-dao-suan-fa-ti-xi-lie/">
        </link>
        <updated>2020-03-09T15:02:13.000Z</updated>
        <summary type="html"><![CDATA[<p>自知算法薄弱，做不到一步登天，那就脚踏实地，聚沙成塔。<br>
不积跬步无以至千里，不积小流无以成江河。</p>
]]></summary>
        <content type="html"><![CDATA[<p>自知算法薄弱，做不到一步登天，那就脚踏实地，聚沙成塔。<br>
不积跬步无以至千里，不积小流无以成江河。</p>
<!-- more -->
<h1 id="20200309">20200309</h1>
<p><strong>题型：树的广度优先遍历</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcokigrjddj31b00pk755.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
var levelOrderBottom = function(root) {
  if (!root) return []
  let result = []
  let depth = 0
  let queue = []
  queue.push(root)
  while (queue.length) {
    result[depth] = []
    let length = queue.length
    for (let i = 0; i &lt; length; i++) {
      queue[i].val !== null &amp;&amp; result[depth].push(queue[i].val)
      if (queue[i].left) queue.push(queue[i].left)
      if (queue[i].right) queue.push(queue[i].right)
    }
    queue.splice(0, length)
    depth++
  }
  return result.reverse()
};
</code></pre>
<p>思路：广度优先遍历需要借助队列，每一层结束了就splice掉，一层一层向下，最后翻转一下就好。<br>
时间复杂度：O(n)</p>
<h1 id="20200310">20200310</h1>
<p><strong>题型：树的深度优先遍历</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcp7mcpe93j31bi0jwdgo.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
var diameterOfBinaryTree = function(root) {
  if (!root) return 0
  let result = 0
  function getMax (root) {
    result = Math.max(result, getDeep(root.left) + getDeep(root.right))
    if (root.left) getMax(root.left)
    if (root.right) getMax(root.right)
    return result
  }
  function getDeep (node, depth = 0) {
    if (node) {
      depth++
      return Math.max(getDeep(node.left, depth), getDeep(node.right, depth))
    } else {
      return depth
    }
  }
  return getMax(root)
};
</code></pre>
<p>思路：方向是对的，深度优先遍历，但是这边有个坑，不能直接两边最大深度相加，因为这个直径可能根本就不经过根节点，所以要把每个节点都当做根节点进行一次递归求两边最大深度与当前result的大值。</p>
<h1 id="20200311">20200311</h1>
<p><strong>题型：数学、双向链表</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcqeh1o63nj312q0u0763.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} A
 * @return {boolean}
 */
var canThreePartsEqualSum = function(A) {
  let sum = getSum(A)
  let left = []
  let right = []
  if (sum % 3 !== 0) return false
  for (let i = 0; i &lt; A.length - 1; i++) {
    left.push(A[i])
    if (getSum(left) === sum / 3) {
      for (let j = A.length - 1; j &gt; i + 1; j--) {
        right.push(A[j])
        if (getSum(right) === sum / 3) {
          return true
        }
      }
      return false
    }
  }
  return false
};

function getSum (arr) {
  return arr.reduce((a, b) =&gt; (a + b), 0)
}
</code></pre>
<p>思路：最重要的是，数组可以分成三段，每段和相同，那么他们一定等于<code>getSum(A) / 3</code>，剩下的就是两边往中间遍历而已。</p>
<h1 id="20200312">20200312</h1>
<p>** 题型：数学 **<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcrld0bogcj314y0u0dh9.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {string} str1
 * @param {string} str2
 * @return {string}
 */
var gcdOfStrings = function(str1, str2) {
  if (str1 === str2) return str1
  if (str1.length &lt; str2.length) {
    let temp = str2
    str2 = str1
    str1 = temp
  }
  let result = ''
  for (let i = 1; i &lt;= str2.length; i++) {
    let temp = str2.slice(0, i)
    if (str1.split(temp).join('') === '' &amp;&amp; str2.split(temp).join('') === '') {
      result = temp
    }
  }
  return result
};
</code></pre>
<p>思路：1、最简单的枚举，从长度1到较小字符串长度一个一个试，2、欧几里得公式，求最大公约数，然后从较小的字符串里取这个长度</p>
<h1 id="20200313">20200313</h1>
<p>** 题型：哈希表 **<br>
169. 多数元素</p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  let timeMap = new Map()
  if (nums.length === 1) return nums[0]
  for (let i = 0; i &lt; nums.length; i++) {
    if (timeMap.has(nums[i])) {
      if (timeMap.get(nums[i]) + 1 &gt; Math.floor(nums.length / 2)) {
        return nums[i]
      }
      timeMap.set(nums[i], timeMap.get(nums[i]) + 1)
    } else {
      timeMap.set(nums[i], 1)
    }
  }
};
</code></pre>
<p>思路：hashmap存储元素出现的次数，比较简单</p>
<h1 id="20200314">20200314</h1>
<p>** 题型：动态规划 **<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gctu5hfdfrj31bq0jkmya.jpg" alt="最长上升子序列" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  let maxUpList = []
  for (let i = 0; i  &lt; nums.length; i++) {
    if (!maxUpList.length) {
      maxUpList.push(nums[i])
    } else if (maxUpList.slice(-1) &lt; nums[i]) {
      maxUpList.push(nums[i])
    } else {
      let index = maxUpList.findIndex(item =&gt; item &gt;= nums[i])
      maxUpList[index] = nums[i]
    }
  }
  return maxUpList.length
};

// 动态规划版本
var lengthOfLIS = function(nums) {
  let dp = new Array(nums.length).fill(1)
  for (let i = 1; i &lt; nums.length; i++) {
    for (let j = 0; j &lt; i; j++) {
      if (nums[j] &lt; nums[i]) {
        // 状态转移方程
        dp[i] = Math.max(dp[j] + 1, dp[i])
      }
    }
  }
  return dp.reduce((pre, cur) =&gt; Math.max(pre, cur), 0)
};
</code></pre>
<p>思路：最开始的思路就是对整个数组进行一次遍历，往后插入大值，小值可以替换前面的值，因为遍历还是线性的，所以时间复杂度还是O(n^2)<br>
从动态规划的角度来看，dp[j] = dp[i] + 1，只要满足j位置的值大于前面i位置的值，那么就可以和i位置的最长上升子序列组成一个更长的最长上升子序列，因为每次到j时都得变量一遍前面i个位置的值，所以时间复杂度还是O(n^2)，使用的数组长度小于等于原数组长度，空间复杂度O(n)</p>
<h1 id="20200316">20200316</h1>
<p>** 题型：空间换取时间 **<br>
<a href="https://leetcode-cn.com/problems/compress-string-lcci/">试题 01.06. 字符串压缩</a><br>
思路：用两个组分别存储重复字符和重复字符的长度，最后进行一次比较即可</p>
<h1 id="20200317">20200317</h1>
<p>** 题型：哈希表计数 **<br>
<a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/">1160. 拼写单词</a></p>
<pre><code class="language-javascript">var countCharacters = function(words, chars) {
  let map = {}
  for (let i = 0; i &lt; chars.length; i++) {
    if (!map[chars[i]]) {
      map[chars[i]] = 1
    } else {
      map[chars[i]] = map[chars[i]] + 1
    }
  }
  return words.reduce((result, cur) =&gt; {
    let word = {}
    for (let i = 0; i &lt; cur.length; i++) {
      if (word[cur[i]]) {
        word[cur[i]] = word[cur[i]] + 1
      } else {
        word[cur[i]] = 1
      }
    }
    if (Object.keys(word).every(key =&gt; map[key] &gt;= word[key])) {
      return result + cur.length
    } else {
      return result
    }
  }, 0)
};
</code></pre>
<h1 id="20200318">20200318</h1>
<p>** 题型：数学 **<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyh1i751cj312q0u0761.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} rec1
 * @param {number[]} rec2
 * @return {boolean}
 */
var isRectangleOverlap = function(rec1, rec2) {
  let [x1, y1, x2, y2] = rec1
  let [x3, y3, x4, y4] = rec2
  return hasjiaoji([x1, x2], [x3, x4]) &amp;&amp; hasjiaoji([y1, y2], [y3, y4])
};

function hasjiaoji (arr1, arr2) {
  let da1 = Math.max(arr1[0], arr1[1])
  let da2 = Math.max(arr2[0], arr2[1])
  let xiao1 = Math.min(arr1[0], arr1[1])
  let xiao2 = Math.min(arr2[0], arr2[1])
  if (
    da1 &lt;= xiao2 || xiao1 &gt;= da2
  ) {
    return false
  } else {
    return true
  }
}
</code></pre>
<p>思路：看x轴和y轴是否两两相交，如果是则必有面积重叠</p>
<h1 id="20200319">20200319</h1>
<p>** 题型：哈希表 || Set **<br>
<a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></p>
<pre><code class="language-javascript">/**
 * @param {string} s
 * @return {number}
 */
var longestPalindrome = function(s) {
  let map = {}
  for (let i = 0; i &lt; s.length; i++) {
    if (map[s[i]]) {
      map[s[i]] = map[s[i]] + 1
    } else {
      map[s[i]] = 1
    }
  }
  let hasSingle = false
  return Object.values(map).reduce((result, cur) =&gt; {
    if (cur % 2 !== 0 &amp;&amp; !hasSingle) {
      hasSingle = true
    }
    return result + (Math.floor(cur / 2) * 2)
  }, 0) + (hasSingle ? 1 : 0)
};
</code></pre>
<p>思路：<br>
1、能组成回文则出现偶数次，若有一个字符出现奇数次，回文长度加一<br>
2、使用Set数据结构，set.has，则长度加2，并set.delete该值，若不存在则set.add</p>
<h1 id="20200322前两天太忙了今天补上之后继续因为代码可以到力扣看这边简单题只写思路和截图">20200322（前两天太忙了，今天补上之后继续，因为代码可以到力扣看，这边简单题只写思路和截图）</h1>
<p><strong>题型：hash表</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd31jfoh24j315g0rcabe.jpg" alt="" loading="lazy"><br>
思路：先排序，重复出现的元素仅需要比上一个出现的非重复元素大1即可，累加相差的值就是要move的值<br>
<strong>题型：数学</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd33erq644j315a0p475p.jpg" alt="" loading="lazy"><br>
思路：非常硬核的一道题，暴力求解会超时。由于数组中最大的值为1e9也就是10的9次方，因为2^30&lt; 10e9 &lt;2^31也就是说至少需要31位2进制才可以表示这个二进制数，通过num.toString(2)转为二进制之后，遍历每一位上的0和1的个数并统计，当前位汉明距离（任意两个数二进制当前位不同的数量即01组合的个数）等于count[0]*count[1]个，最后31位统一累加，时间复杂度是O(n)，空间复杂度O(1)。</p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var totalHammingDistance = function(nums) {
  let result = 0
  let maxBit = 31 // 最大32位
  nums = nums.map(num =&gt; num.toString(2))
  for (let i = 0; i &lt; maxBit; i++) {
    let count = {
      '0': 0,
      '1': 0
    }
    for (let j = 0; j &lt; nums.length; j++) {
      let cur = nums[j]
      count[+cur[cur.length - i - 1] ? '1' : '0']++
    }
    result += count[0] * count[1]
  }
  return result
};
</code></pre>
<h1 id="20200323">20200323</h1>
<p><strong>题型：链表</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd4aa3oh6bj31410u0jt8.jpg" alt="" loading="lazy"><br>
思路：<br>
1、单指针两次遍历，第一次记录长度，第二次访问到中间长度时返回节点<br>
2、快慢指针，快指针一次移动两格，慢指针一次移动一格，快指针到达链表尾部时，慢指针也就在中间了~</p>
<h1 id="20200324">20200324</h1>
<p>** 题型：动态规划**<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd5eehkstfj313b0u0jt9.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var massage = function(nums) {
  let dp = []
  dp[0] = nums[0]
  dp[1] = Math.max(nums[1], nums[0])
  for (let i = 2; i &lt; nums.length; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
  }
  return dp[nums.length - 1] || 0
};
</code></pre>
<p>每次做到动态规划的题总是知道这道题要用动态规划，可是就是做不出来。。<br>
思路：<code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])</code>。每次中间需要间隔，三个一组，但是不是0,3到3,6，而是0,3到1,4，像滑动窗口一样划过去，计算每个点位的最大值，最后返回dp[i]即可。</p>
<h1 id="20200325">20200325</h1>
<p><strong>题型：数学</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd6ncibrylj30u00vg41h.jpg" alt="" loading="lazy"><br>
思路：横向，竖向分别遍历一次，按条件捕获即可，时间复杂度O(n^2)。</p>
<h1 id="20200326">20200326</h1>
<p><strong>题型：动态规划</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd7rocy4lwj315c0q00to.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  let dp = []
  let max = nums[0]
  dp[0] = nums[0]
  for (let i = 1; i &lt; nums.length; i++) {
    if (dp[i - 1] &lt; 0) {
      dp[i] = nums[i]
    } else {
      dp[i] = dp[i - 1] + nums[i]
    }
    max = Math.max(dp[i], max)
  }
  return max
};
</code></pre>
<p>思路：动态规划，dp[i - 1]为负时相当于前面的总和已经是负收益，dp[i]直接等于当前值即可，转移方程是 -&gt; dp[i] = dp[i - 1]是负数 ？nums[i] : dp[i - 1] + nums[i]。</p>
<h1 id="20200326-2">20200326</h1>
<p><strong>题型：最小公约数</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd8x3w716qj30u30u0dhi.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} deck
 * @return {boolean}
 */
var hasGroupsSizeX = function(deck) {
  let arr = {}
  for (let i = 0; i &lt; deck.length; i++) {
    if (arr[deck[i]] !== void 0) {
      arr[deck[i]] = arr[deck[i]] + 1
    } else {
      arr[deck[i]] = 1
    }
  }
  let g = -1
  for (let i = 0; i &lt; 10000; i++) {
    if (arr[i]) {
      if (g === -1) {
        g = arr[i]
      } else {
        g = gcd(g, arr[i])
      }
    }
  }
  return g &gt;= 2
};

// 求最大公约数！谨记，如果x（余）为0，则最大公约数是上一次的x，这一次的y
function gcd (x, y) {
  return x === 0 ? y : gcd(y % x, x)
}
</code></pre>
<p>思路：先记录所有数字出现的次数，再根据题意最大值不超过10000，求最小公约数，gcb公式（Greatest Common Divisor）要牢记！还有另一种思路，就是记录最大值，遍历到这个最大值最大公约数是否大于2。</p>
<h1 id="20200327">20200327</h1>
<p><strong>题型：动态规划</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdax9wbqysj314s0ksgmc.jpg" alt="" loading="lazy"><br>
思路：<br>
1、&gt;&gt; 符号在js里，如果是&gt;&gt;0相当于Math.floor取整，如果是&gt;&gt;1则表示将2进制位右移一位，并补位0<br>
2、Array.from(arr, item =&gt; item + 1)，Array的第二个参数是一个回调，可以操作前面的类数组，并最后返回一个数组<br>
3、最长回文子可以通过暴力枚举、反转字符串求公共子串、动态规划来做<br>
动态规划：将i，j表示为i到j的字符串，值表示为是否是回文子串动态规划方程是<br>
dp[i][j] = dp[i + 1][j - 1] &amp;&amp; s[i] === s[j]<br>
true表示是回文串，反之不是</p>
<h1 id="20200328">20200328</h1>
<p><strong>题型：数学</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb5vnmdv2j315g0mat9v.jpg" alt="" loading="lazy"><br>
思路：1、正常思路，控制递增变量，取递增最大的那一次，时间复杂度O(n)，空间复杂度O(1)<br>
2、动态规划，下一个数大于上一个数则 dp[i] = dp[i - 1] + 1 否则 dp[i] = 1</p>
<h1 id="20200329">20200329</h1>
<p><strong>题型：经典约瑟夫环</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdgigcuovbj315a0oadh0.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number} n
 * @param {number} m
 * @return {number}
 */
var lastRemaining = function(n, m) {
  if (m === 1) return n - 1
  let arr = []
  for (let i = 0; i &lt; n; i++) {
    arr.push(i)
  }
  let idx = 0
  while (arr.length !== 1) {
    idx = (idx + m - 1) % arr.length
    arr.splice(idx, 1)
  }
  return arr[0]
}
</code></pre>
<p>思路：每次删除后，记录下当前的位置，下次再对数组长度求余，得到新的要删除的位置，勉强通过</p>
<h1 id="20200330">20200330</h1>
<p><strong>题型：分治</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gddjsv04n3j31580qcgmf.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
  if (nums.length &lt;= 1) {
    return nums
  }
  // 归并排序
  let length = nums.length
  let mid = (length / 2) &gt;&gt; 0
  let left = nums.slice(0, mid)
  let right = nums.slice(mid, length)
  return merge(sortArray(left), sortArray(right))
};

function merge (left, right) {
  let result = []
  while (left.length &amp;&amp; right.length) {
    if (left[0] &lt; right[0]) {
      result.push(left.shift())
    } else {
      result.push(right.shift())
    }
  }
  return result.concat(left).concat(right)
}
</code></pre>
<p>思路：Array.sort本质上是快排，选择，归并的合集，根据数组长度来选择最佳的排序规则，做到这道题时想学习一下归并。归并排序采用的是分而治之的思想，将数组拆分成一个一个的小数组进行排序，然后将排序好的小数组再进行一次排序，长度为n的数组本质上仅需要log2n次拆分，时间复杂度为nlogn</p>
<h1 id="20200331">20200331</h1>
<p><strong>题型：栈</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdeoe7snr9j30yx0u0whl.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {string} seq
 * @return {number[]}
 */
var maxDepthAfterSplit = function(seq) {
  if (!seq.length) return []
  let result = [0]
  let A = [seq[0]]
  let B = []
  for (let i = 1; i &lt; seq.length; i++) {
    // A.slice(-1)
    if (seq[i] === ')') {
      if (A.length &gt; B.length) {
        A.length = A.length - 1
        result.push(0)
      } else {
        B.length = B.length - 1
        result.push(1)
      }
    } else {
      if (A.length &gt; B.length) {
        B.push(seq[i])
        result.push(1)
      } else {
        A.push(seq[i])
        result.push(0)
      }
    }
  }
  return result
};
</code></pre>
<p>思路：保持AB组的深度一致，相差不超过1即可，可以找规律，也可以像我这样暴力破解，哈哈哈哈哈哈哈哈哈嗝，时间复杂度N，空间复杂度1</p>
<h1 id="20200401">20200401</h1>
<p>** 题型：数学 **<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdfvup02njj30x20u0acu.jpg" alt="" loading="lazy"><br>
思路：没什么好说的，按题意来，8个方向都取一次，时间复杂度O(n^2)，空间复杂度O(n)</p>
<h1 id="20200402">20200402</h1>
<p>** 题型：数学 **<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdgieglimnj30uq0u0422.jpg" alt="" loading="lazy"><br>
思路：耐心题，确认好函数边界，虚怀若谷，沉住气</p>
<h1 id="20200403">20200403</h1>
<p>** 题型：数学（木板效应） **<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdi7b4d6cmj314y0okjs7.jpg" alt="" loading="lazy"><br>
思路：根据木板效应，每一个能接的水取决于左右两边最短的那一块减去当前木板高度的值，暴力法求解，时间复杂度O(n^2)</p>
<h1 id="20200404">20200404</h1>
<p>** 题型：LFU算法 **<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdjcz4hl7dj30u00wr40r.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">let LFUCache = class {
    constructor(capacity) {
        this.limit = capacity
        this.cache = new Map()
        this.freqMap = new Map()
    }

    get(key) {
        let cache = this.cache
        let r = -1
        if (typeof cache[key] != &quot;undefined&quot;) {
            let o = cache[key]
            r = o.value
            //更新频率记录
            this.updateL(key, o)
        }
        return r
    };

    updateL(key, obj){
        let freq = obj.freq;
        let arr = this.freqMap[freq]
        // 删除原频率记录
        this.freqMap[freq].splice(arr.indexOf(key), 1)
        // 清理
        if (this.freqMap[freq].length == 0) delete this.freqMap[freq]
        // 更新频率
        freq = obj.freq = obj.freq + 1
        if (!this.freqMap[freq]) this.freqMap[freq] = []
        this.freqMap[freq].push(key)
    }

    put(key, value) {
        let cache = this.cache
        let limit = this.limit
        let fmap = this.freqMap
        if (limit &lt;= 0) return
        if(typeof key==&quot;undefined&quot;||typeof value==&quot;undefined&quot;) throw new Error('key or value is undefined')
        // 存在则直接更新
        if (typeof cache[key] == &quot;undefined&quot;) {
            // 获取频率 key
            // 判断容量是否满
            if (Object.keys(cache).length == limit) {
                let fkeys = Object.keys(fmap)
                let freq = fkeys[0]
                // 获取key集合
                let keys = fmap[freq]
                // 淘汰首位
                delete cache[keys.shift()]
                // 清理
                if (fmap[freq].length == 0) delete fmap[freq]
            }
            // 频率记录是否存在
            if (!fmap[1]) fmap[1] = []
            // 插入新值
            fmap[1].push(key)
            cache[key] = {
                value: value,
                freq: 1 // 默认的频率
            }
        } else {
            cache[key].value = value
            //更新频率记录
            this.updateL(key, cache[key])
        }
    };
};
</code></pre>
<p>思路：跟LRU不同，LRU是根据时间来清除最久未使用的数据，LFU是根据频率来清除最久未使用的数据，为了节省时间，这边需要两个map，一个cacheMap用来存储key对应key的val和freq频率，一个freqMap用来存储每一种freq频率对应的keyArr，以便在相同频率的情况下删除最前面的数据，更新map。（做的我自闭了</p>
<h1 id="20200405">20200405</h1>
<p><strong>题型： 排序</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdkfqwhd5vj30yo0r274y.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 */
var getLeastNumbers = function(arr, k) {
  var sort = incorporateSort(arr)
  return sort.slice(0, k)
};

var incorporateSort = function (arr) {
  if (arr.length &lt;= 1) return arr
  let mid = Math.floor(arr.length / 2)
  let left = arr.slice(0, mid)
  let right = arr.slice(mid)
  return merge(incorporateSort(left), incorporateSort(right))
}

var merge = function (left, right) {
  let result = []
  while (left.length &amp;&amp; right.length) {
    if (left[0] &lt; right[0]) {
      result.push(left.shift())
    } else {
      result.push(right.shift())
    }
  }
  return result.concat(left).concat(right)
}
</code></pre>
<p>思路：<br>
1、排序，我用了归并，分治的思想<br>
2、（因为这里没有规定要按顺序返回）最小栈，维护一个栈，先将k个数推入栈内，然后从k+1个数开始遍历，如果它比顶部值要小（最小的k个数肯定会满足这个条件），那就插入栈的尾部，最后返回该栈元素</p>
<h1 id="20200406">20200406</h1>
<p><strong>题型：动态规划+缓存</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdlo2f0p7mj30z80ju0ti.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
  this.nums = nums
  this.record = new Array(nums.length)
  this.record[0] = nums[0]
  for (let i = 1; i &lt; nums.length; i++) {
    this.record[i] = this.nums[i] + this.record[i - 1]
  }
};

/** 
 * @param {number} i 
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  if (i === 0) return this.record[j]
  return this.record[j] - this.record[i - 1]
};
</code></pre>
<p>思路：刚开始想的就是动态规划，结果一做超时，想着用map来缓存求过的值，一做，还是超时，正确的思路是新建一个记录数组，每个位置为0到该位置的和，那么有sum(i, j) = record[j] - record[i - 1]成立，每次只要计算减法就好了，时间复杂度O(n)比动规O(n^2)效率高很多。</p>
<h1 id="20200407">20200407</h1>
<p><strong>题型：寻路算法、dfs、bfs</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdmslwmxf3j30q20tejsf.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number} m
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var movingCount = function(m, n, k) {
  let result = 0
  let record = {}
  let runner = function (a, b) {
    if (a &gt;= m || b &gt;= n || a &lt; 0 || b &lt; 0) {
      return
    }
    let sum = getSum(a) + getSum(b)
    let axis = JSON.stringify([a, b])
    if (sum &lt;= k &amp;&amp; !record[axis]) {
      result++
      record[axis] = true
      runner(a + 1, b)
      runner(a - 1, b)
      runner(a, b + 1)
      runner(a, b - 1)
    }
  }
  runner(0, 0)
  return result
};

function getSum (num) {
  let res = 0
  while (num &gt; 0) {
    res += num % 10
    num = Math.floor(num / 10)
  }
  return res
}
</code></pre>
<p>思路：好题。题中只能上下左右移动因此可以将不满足条件的点想成砖块，同时对满足砖块的每个点做上下左右移动的操作，并记录到过的点位，可以计出总数。另外求和总数，每次除10求余数，然后除以10，继续取余数，得到位数和。</p>
<h1 id="20200408">20200408</h1>
<p><strong>题型：深度优先遍历</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdnwqsy70vj30wm0n0wez.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  let result = []
  const dfs = function (str, leftNumber, rightNumber) {
    if (str.length === n * 2) {
      result.push(str)
      return
    }
    if (rightNumber &lt; leftNumber) return
    if (leftNumber === n) {
      dfs(str + '(', leftNumber - 1, rightNumber)
    } else {
      leftNumber &gt; 0 &amp;&amp; dfs(str + '(', leftNumber - 1, rightNumber)
      rightNumber &gt; 0 &amp;&amp; dfs(str + ')', leftNumber, rightNumber - 1)
    }
  }
  dfs('', n, n)
  return result
};
</code></pre>
<p>思路：深度优先遍历，先全部左括弧，然后一个一个右括弧往上叠加，注意有效的括号左括弧的数量要始终大于等于右括弧的数量。最后返回所有结果。</p>
<h1 id="20200409">20200409</h1>
<p><strong>题型：位运算</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdnxbgkm2bj30w40q0zl3.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number} num
 * @return {number[]}
 */
var findClosedNumbers = function(num) {
  let times = getOneTimes(num)
  let min = -1
  let max
  let i = num
  let j = num
  while (!max) {
    ++i
    if (getOneTimes(i) === times) {
      max = i
    }
  }
  while (min === -1 &amp;&amp; j &gt; 0) {
    --j
    if (getOneTimes(j) === times) {
      min = j
    }
  }
  return [max, min]
};

function getOneTimes (num) {
  let numT = Number(num).toString(2)
  return numT.length - numT.split('1').join('').length
}
</code></pre>
<p>思路： 暴力解法就是从num往两边移动，分别找到符合条件的最大最小的数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[组件库设计思路]]></title>
        <id>https://chentianyuan.github.io/post/zu-jian-ku-she-ji-si-lu/</id>
        <link href="https://chentianyuan.github.io/post/zu-jian-ku-she-ji-si-lu/">
        </link>
        <updated>2020-02-24T06:22:23.000Z</updated>
        <summary type="html"><![CDATA[<p>去年参与了部分公司的组件库建设，md-loader只是一部分，从全局的角度梳理一下整个组件库的设计流程</p>
]]></summary>
        <content type="html"><![CDATA[<p>去年参与了部分公司的组件库建设，md-loader只是一部分，从全局的角度梳理一下整个组件库的设计流程</p>
<!-- more -->
<h1 id="1-文档的归属">1、文档的归属</h1>
<p>一份优质的文档是一个成功的组件库的基础，element-ui的官网文档是经受了无数厂商的考验的，因此md-loader已经是很好的实践。另一个值得权衡的问题是，文档是新开一个项目还是就放在组件库的项目里？<br>
如果放在项目里，组件库一大，项目会略显臃肿，并且每次跑项目都需要把组件进行重新编译，速度堪忧。而如果分离出一个新的项目，则享受不到开发时热更新的遍历，需要把打包文件频繁输出，才能实时看到组件的效果，而且另起一个工程也是有成本的，需要安装两次通用的依赖。<br>
综上：从遍历性的角度来看，还是放在一个项目内会方便得多，除非你的目标是做一个大而美的业界组件库，而不是为了业务需要快速迭代的产物（然而没有资本支撑，估计也没人愿意做这么一套东西）</p>
<h1 id="2-打包配置">2、打包配置</h1>
<h3 id="21-按需打包配置">2.1 按需打包配置</h3>
<p>为了按需加载引入，我们常用<code>babel-plugin-component</code>或<code>babel-plugin-syntax-dynamic-import</code>这两个babel插件来使得<code>import { WandUploader } from @weiyi/wand-ui</code>变成<code>import /node_modules/@weiyi/wand-ui/libaryName/uploader/index.js</code>+组件css引入（通用css会从libaryName下引入）来实现。因此我们要将每个组件作为单独入口打包出index.js和组件的css，组件css可以使用<code>MiniCssExtractPlugin</code>来实现拆分。另外，配置中需要外置化vue，否则vue会被打包进入组件bundle。</p>
<pre><code class="language-javascript">externals: [
    {
        vue: {
        root: 'Vue',
        commonjs: 'vue',
        commonjs2: 'vue',
        amd: 'vue'
        },
        'vue-property-decorator': 'vue-property-decorator'
    }
]
</code></pre>
<h3 id="22-全量打包配置">2.2 全量打包配置</h3>
<p>当我们全量引入某个vue组件库时，在入口处直接使用<code>Vue.use(WandUi)</code>来导入非常方便，因此，我们的全量打包入口文件也应当导出一个install函数，来支持这种插件式引入。</p>
<pre><code class="language-javascript">export default {
  install: (Vue: VueConstructor) =&gt; {
    components.forEach(comp =&gt; {
      if (comp.install) {
          // 针对支持插件式调用的组件，还需要进行一次插件注册
        Vue.use(comp as any)
      } else {
          // 全局组件注册
        Vue.component((comp as any).options.name, comp)
      }
    })
  }
}
</code></pre>
<h3 id="3-便捷组件生成">3、便捷组件生成</h3>
<pre><code class="language-json">{
    &quot;create&quot;: &quot;node build/create-component&quot;,
    &quot;generate&quot;: &quot;node build/create-md&quot;
}
</code></pre>
<p>一键生成新的组件规则，通过读取模板，生成组件主文件，组件样式文件，组件文档，将组件添加进路由等等一系列重复操作，减少开发人员开发成本，也是不可或缺的一部分，通过命令行inquiry式调用，提升开发效率</p>
<h3 id="4-组件命令封装">4、组件命令封装</h3>
<p>文档打包，组件打包，全量、按需、开发、生产，<code>require(&quot;package.json&quot;).script</code>会越来越大，显得十分臃肿且难以理解，封装一个cli，可以增加可读性，减小代码体积，也提升了再建组件库的通用性。</p>
<pre><code class="language-json">&quot;scripts&quot;: {
&quot;bootstrap&quot;: &quot;yarn || npm i&quot;,
&quot;dev&quot;: &quot;vant-cli dev&quot;,
&quot;lint&quot;: &quot;vant-cli lint&quot;,
&quot;test&quot;: &quot;vant-cli test&quot;,
&quot;build&quot;: &quot;vant-cli build&quot;,
&quot;release&quot;: &quot;vant-cli release&quot;,
&quot;test:watch&quot;: &quot;vant-cli test --watch&quot;,
&quot;release:site&quot;: &quot;sh docs/site/release.sh&quot;,
&quot;test:coverage&quot;: &quot;open test/coverage/index.html&quot;
}
</code></pre>
<h1 id="总结">总结</h1>
<p>一个好的组件库不仅在组件本身的通用性，易用性，也在于整体组件库架构设计的可重用性，规范性，易扩展性，市面上的组件库层次不齐，组件库设计可以参考大的如element-ui，ant-design，vant等优秀组件库进行设计</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[md-loader详解]]></title>
        <id>https://chentianyuan.github.io/post/md-loader-xiang-jie/</id>
        <link href="https://chentianyuan.github.io/post/md-loader-xiang-jie/">
        </link>
        <updated>2020-02-14T06:54:48.000Z</updated>
        <summary type="html"><![CDATA[<p>没有你的日子里，我真的好想你<br>
枯了，年前1月20送修的电脑，一个月了才拿回来🤕</p>
]]></summary>
        <content type="html"><![CDATA[<p>没有你的日子里，我真的好想你<br>
枯了，年前1月20送修的电脑，一个月了才拿回来🤕</p>
<!-- more -->
<p>这篇文章加强认知的同时，使用一下star法则，加强表达能力</p>
<h2 id="situation-情景">situation 情景</h2>
<p>公司的组件库出第二版了，技术栈是vue2.6+ts，项目写到快要验收的阶段，问题出现了。组件库的文档在直接使用markdown-loader解析md的情况下，出现了md和demo不对应的情况。（有些开发者（好吧就是我自己。。）组件写完，文档写完，发现还要写.vue的demo组件，在本身还有繁杂业务需求的情况下，开始焦躁不已，demo也就草草了事了），对一些复杂组件，一个不和文档对应的demo，跟没有一样。因此，我们把目光瞄向了文档demo对应的element-ui。</p>
<h2 id="task-任务">task 任务</h2>
<p>任务就是创建出一套md和demo对应的组件文档。</p>
<h2 id="action-执行">action 执行</h2>
<p>确认过眼神，我遇上对的loader。看到element用md作为vue-router的路由组件的时候，element-ui的md-loader应该就是我们想要的东西。<br>
md中使用</p>
<pre><code>::: demo
```html
&lt;action-sheet&gt;...&lt;/actionsheet&gt;
export default { ... }
\```
:::
</code></pre>
<p>包裹的东西最后会转成我们的demo，因此我们只要写一份md就能得到demo和文档了。</p>
<h3 id="md-loader">md-loader</h3>
<p>一个webpack loader说白了其实就是一个接受source的function，函数处理source之后，返回一个新的source交给下个loader处理。</p>
<h3 id="来康康md-loader的处理顺序">来康康md-loader的处理顺序</h3>
<p>1、获取处理好的md<br>
这边分几种情况</p>
<ul>
<li>普通的md语法 交由markdown-it来解析，得到标签包裹好的文本</li>
<li>对于被:::demo所包裹的sfc语法，进行两步操作。
<ul>
<li>将这部分代码用<code>&lt;!--element-demo: :element-demo--&gt;</code>包裹，这个属于一个占位符，在我们遍历demo时便是以这个来标识demo代码的起点和终点的</li>
<li>再使用<code>&lt;demo-block&gt;...&lt;/demo-block&gt;</code>包裹</li>
<li>得到一份新的md</li>
<li>针对新的md，改变markdown对demo块的处理方式，并放入<code>&lt;template slot=&quot;highlight&quot;&gt;</code>中，作为代码展示部分</li>
</ul>
<pre><code>if (token.info === 'html' &amp;&amp; isInDemoContainer) {
  return `&lt;template slot=&quot;highlight&quot;&gt;&lt;pre v-pre&gt;&lt;code class=&quot;html&quot;&gt;${md.utils.escapeHtml(token.content)}&lt;/code&gt;&lt;/pre&gt;&lt;/template&gt;`;
}
</code></pre>
<ul>
<li><code>md.render(source)</code> 得到最后的代码块</li>
</ul>
</li>
</ul>
<p>2、处理代码块，将其变成vue-loader能够处理的模样<br>
其实，如果md中只有一个demo，根本没有必要进行这步处理，将模板直接塞入source，交给vue-loader处理就好了。可是理想很美好，现实很骨感，每个md一般会有多个demo块，如果共用一份状态，必须混合状态，且状态名不能重复，非常不方便，因此md-loader是这样处理的。</p>
<pre><code>const demoComponentName = `element-demo${id}`;
output.push(`&lt;template slot=&quot;source&quot;&gt;&lt;${demoComponentName} /&gt;&lt;/template&gt;`);
</code></pre>
<p>对每个块插入一个<code>element-demo${id}</code>组件，然后这个组件，就是我们接下来要生成的了，确保了每个demo都是独立互不干扰的。最后这些组件会通过插槽的形式，插入demo-block组件提供的槽位中。</p>
<h3 id="生成element-demoid组件的render函数">生成element-demo${id}组件的render函数</h3>
<p>依赖的两个库分别是<code>@vue/component-compiler-utils</code>和<code>vue-template-compiler</code>，</p>
<ul>
<li><code>let demoComponentContent = genInlineComponentText(html, script);</code> 通过genInlineComponentText函数生成我们所需的组件代码</li>
<li>将合法的options传给<code>@vue/component-compiler-utils</code>中提供的<code>compileTemplate</code>函数</li>
</ul>
<pre><code class="language-javascript">  const finalOptions = {
    source: `&lt;div&gt;${template}&lt;/div&gt;`,
    filename: 'inline-component', // TODO：这里有待调整
    compiler
  };
  const compiled = compileTemplate(finalOptions);
  let demoComponentContent = `
    ${compiled.code}
  `;
  demoComponentContent = `(function() {
    ${demoComponentContent}
    ${script}
    return Object.assign({
      render,
      staticRenderFns
    }, democomponentExport)
  })()`;
  return demoComponentContent;
</code></pre>
<ul>
<li>最后的demoComponentContent就是我们要的script了~<br>
举个例子，最后的demoComponentContent的样子类似这样</li>
</ul>
<pre><code class="language-javascript">&quot;element-demo0&quot;: (function () {
    var render = function (_c) { return _c(....) }
    var staticRenderFns = []
    const democomponentExport = {
        data () {
            return {
            value1: false,
            actions1: [
                { value: 1, label: '项目1' }, 
                { value: 2, label: '项目2' }, 
                { value: 3, label: '项目3' }
            ]
            }
        },
        ...options
    }
    return Object.assign({
        render,
        staticRenderFns
    }, democomponentExport)
})
</code></pre>
<h2 id="result-结果">result 结果</h2>
<p>将生成的模板，和得到的element-demo${id}组件script一起，插入到新的模板中</p>
<pre><code class="language-javascript">// md-loader
  return `
    &lt;template&gt;
      &lt;section class=&quot;content wand-doc&quot; :class=&quot;'wand-doc-' + $route.fullPath.substring(1)&quot;&gt;
        ${output.join('')}
      &lt;/section&gt;
    &lt;/template&gt;
    ${pageScript}
  `;
</code></pre>
<p>下一步便由vue-loader处理了，生成整个路由组件的render函数并在路由访问时执行并挂载到页面上！最后我们看到的文档和demo就是一一对应的了，看起来非常得直观。<br>
<img src="https://chentianyuan.github.io/post-images/1581670429040.png" alt="" loading="lazy"><br>
完成！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js垃圾回收机制]]></title>
        <id>https://chentianyuan.github.io/post/js-la-ji-hui-shou-ji-zhi/</id>
        <link href="https://chentianyuan.github.io/post/js-la-ji-hui-shou-ji-zhi/">
        </link>
        <updated>2020-01-16T03:55:24.000Z</updated>
        <summary type="html"><![CDATA[<p>每种语言都有垃圾回收机制，来回收不再使用的内存空间，垃圾回收又分为主动回收和被动回收两种...</p>
]]></summary>
        <content type="html"><![CDATA[<p>每种语言都有垃圾回收机制，来回收不再使用的内存空间，垃圾回收又分为主动回收和被动回收两种...</p>
<!-- more -->
<p>在js，python，java中使用的都是自动垃圾回收机制，开发者无需主动清除变量所占用的内存，但是在某些场景下，关注内存情况还是很必要的。</p>
<p>js中的变量都存储在栈和堆中，二者回收机制也不同。</p>
<h2 id="栈内存回收">栈内存回收</h2>
<p>js代码会放到一个执行栈中运行，每碰到一个运行函数的指令，就为当前函数创建执行上下文，然后推入调用栈，当函数执行完毕，则函数出栈，开始执行下一个任务。<br>
js内部会有一个ESP(记录当前执行状态的指针)，该指针总是指向当前的执行上下文，当函数执行完毕ESP指针下移之后，还会销毁ESP上一个指向的函数保存在栈中的执行上下文，从而自动回收其中保存在栈中基本类类型的内存。</p>
<h2 id="堆内存回收">堆内存回收</h2>
<p><strong>基本类型存在栈中的内存会随着执行上下文被销毁而自动回收</strong>，而堆内存需要额外的机制来进行回收。</p>
<h3 id="代际假说the-generational-hypothesis">代际假说(The Generational Hypothesis)</h3>
<ul>
<li>大部分对象在内存中存活的时间很短，很多对象占用的内存一经分配就变得不可访问 (新生代)</li>
<li>不死的对象会活得更久 (老生代)<br>
为了对这两种情况下的垃圾进行回收，在V8中会把堆内存分为新生代和老生代两个区域。<br>
新生代的容量较小，老生代容量大。然后针对这两种区域分别使用<code>副回收器(新生代)</code>和<code>主回收器(老生代)</code>对垃圾进行回收。</li>
</ul>
<h3 id="副垃圾回收器">副垃圾回收器</h3>
<p><img src="https://chentianyuan.github.io/post-images/1579243473477.png" alt="新生代和老生代" loading="lazy"><br>
副垃圾回收器使用的是一种Scavenge算法来处理垃圾的，新生代会被对半划分为对象区域和空闲区域，新加入的对象会加入对象区域，当对象区域快被写满的时候就会开始垃圾回收。</p>
<ul>
<li>标记对象区域还在使用的对象</li>
<li>将被标记的对象复制到空闲区域</li>
<li>对复制后的对象做内存整理操作，合并内存间隙</li>
<li>角色翻转，将对象区域转为空闲区域，对空闲区域转为对象区域，上一次未被标记的对象占用的内存则被垃圾回收<br>
如果新生代内存设置得过大，那么每次清理时间就会过久，造成程序运行缓慢，所以为了执行效率，一般新生代的空间会设的比较小，js中一般是1~8M。新生代的内存区域不大如果都放在新生代则容易被存活对象占满整个区域，所以js引擎采用了<code>对象晋升策略</code>，进过两次垃圾回收依然存活的对象，会被移动到老生代中。另外除了从新生区晋升的对象外，一些比较大的对象会直接被分配到老生代。</li>
</ul>
<h3 id="主垃圾回收器">主垃圾回收器</h3>
<p>主垃圾回收器负责回收老生代区域的垃圾对象，它有内存大，存活时间长等特点，如果继续采用Scavenge算法，拷贝大内存对象十分耗时，导致垃圾回收执行效率不高。因此，主垃圾回收器采用的是<code>标记清除</code>垃圾回收算法。<br>
<img src="https://chentianyuan.github.io/post-images/1579244309852.png" alt="主垃圾回收器" loading="lazy"><br>
主垃圾回收器会定期遍历当前的调用栈，然后对当前老生代中的对象使用情况进行标记，如果在调用栈发现了对对象的引用则标记为活动对象，否则标记为垃圾数据。<br>
当对老生代的垃圾回收之后进行<code>标记整理</code>使所有对象向一端移动清除内存间隙。</p>
<h3 id="增量标记算法只针对老生代才有标记清除算法">增量标记算法（只针对老生代才有标记清除算法）</h3>
<p>由于如果js运行的主线程是单线程作业，如果垃圾积攒过多，比如1.5G的老生代需要大约1s的时间进行回收，那么js运行会被垃圾回收阻塞，页面就会有明显的卡顿。因此，为了避免垃圾回收对程序运行带来的影响，V8将标记过程分为一个个的子标记过程，垃圾回收标记和js应用逻辑交替运行，这种算法叫增量标记算法，将一个完整的垃圾回收任务分为很多个小任务，用户就不会因为垃圾回收的阻塞而感到卡顿了。(但是其实这也是在刷题的时候感觉js运行效率不高的原因吧= =，在逻辑运算过程中还穿插了垃圾回收，向java这种多线程语言垃圾回收应该是单独一个线程吧猜想(¦3[▓▓] )。</p>
<h3 id="总结">总结</h3>
<p>懒一下，之后总结。。。😹😹😹</p>
<h2 id="资料参考">资料参考</h2>
<p><a href="https://time.geekbang.org/column/article/131233">极客时间浏览器工作原理与实践（李兵）</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue生命周期（简略版）]]></title>
        <id>https://chentianyuan.github.io/post/vue-sheng-ming-zhou-qi/</id>
        <link href="https://chentianyuan.github.io/post/vue-sheng-ming-zhou-qi/">
        </link>
        <updated>2020-01-11T05:42:15.000Z</updated>
        <summary type="html"><![CDATA[<p>通过 debugger vue 源码 观察得出的vue生命周期流程<br>
对vue的生命周期进行深入了解 (*/ω＼*)</p>
]]></summary>
        <content type="html"><![CDATA[<p>通过 debugger vue 源码 观察得出的vue生命周期流程<br>
对vue的生命周期进行深入了解 (*/ω＼*)</p>
<!-- more -->
<blockquote>
<p>版本：vue2.6.11 完整版本</p>
</blockquote>
<p>附官方配图<br>
<img src="file:///Users/apple/Documents/Gridea/post-images/1578721758426.png" style="zoom:50%" /></p>
<p>一切的一切要从vue文件加载说起</p>
<h2 id="init">init</h2>
<p>无论是模块化引入，还是script标签加载，都会引入vue的bundle文件，在进入生命周期之前，vue会执行如下几个方法<br>
往vue的构造函数上挂载之后需要用到的变量，往原型上挂载要用到的方法<br>
修改push，pop等数组操作方法，使用包装器包装</p>
<pre><code class="language-javascript">// initGlobalAPI
initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
</code></pre>
<h2 id="new-vueoptions">new Vue(options)</h2>
<p>新建vue实例的时候，构造函数内只有一个入口<code>this._init(options);</code></p>
<h2 id="mergeoptionsconstructoroptions-options-vm">mergeOptions(constructor.options, options, vm)</h2>
<p>将initGlobalApi中初始化的构造函数上的属性和传入的属性做一次merge，此时，一些我们平常没有注入的Component，keep-alive，transition，transition-group三个内置组件也是在这里被merge进我们的option的。值得一提的是，这里的merge不是简单的对象合并，针对不同的option，会采用不同的合并策略，比如data执行后合并成新的data函数，生命周期钩子，则被推入对应生命周期数组中</p>
<h2 id="beforecreate">beforeCreate</h2>
<pre><code class="language-javascript">initLifecycle(vm);
initEvents(vm);
initRender(vm);
callHook(vm, 'beforeCreate');
</code></pre>
<p>执行beforeCreate钩子，此时的数据还不是响应式，真实dom也没有挂载到页面，页面还是带vue语法的模板</p>
<h2 id="数据监测">数据监测</h2>
<p>从data函数开始，<code>data.call(vm, vm)</code>得到data对象，对data对象的每个属性进行监测，为每个属性新建一个dep对象<code>const dep = new Dep()</code>，通过<code>Obejct.defineProperty</code>设置对应属性的get，set，在get中进行依赖收集，需要收集的地方会将Dep.target加到dep.sub中<code>dep.addSub(Dep.target)</code>，在被set时，通过<code>dep.notify() =&gt; watcher.cb()</code>来通知模板更新，如果属性是数组，其数组操作方法在初始化时已经被替换，则在各个操作方法中进行通知。如果当前key对应的属性仍不是基本类型，则继续进行深度遍历，知道所有属性被监听。除了data这一阶段还包括对watcher和computed的处理。</p>
<h2 id="create">Create</h2>
<p>这一阶段还包括了父组件provide和子组件inject的初始化处理，数据监听完毕，触发create钩子</p>
<pre><code class="language-javascript">initInjections(vm); // resolve injections before data/props
initState(vm);
initProvide(vm); // resolve provide after data/props
callHook(vm, 'created');
</code></pre>
<h2 id="模板编译阶段-compiletofn">模板编译阶段 CompileToFn</h2>
<p>vue分两种版本，一种是包含模板编译大一点的版本，一种是vue.runtime.js，只包含运行时的版本，在使用webpack构建时常使用vue-loader来预处理模板，因此到页面上只需引入运行时的vue版本就好了，而没有使用模板编译的话，只能引入全量的vue了。所谓模板编译，其实就是template到render函数的过程，中间通过ast转化，通过正则匹配来确定是普通的html语法还是vue的特殊语法从而进行不同的特殊处理，最后得到一个类似这样的render函数</p>
<pre><code class="language-javascript">(function anonymous(
) {
with(this){return _c('div',{attrs:{&quot;id&quot;:&quot;demo&quot;}},[_c('h1',[_v(&quot;Latest Vue.js Commits&quot;)]),_v(&quot; &quot;),_l((branches),function(branch){return [_c('input',{directives:[{name:&quot;model&quot;,rawName:&quot;v-model&quot;,value:(currentBranch),expression:&quot;currentBranch&quot;}],attrs:{&quot;type&quot;:&quot;radio&quot;,&quot;id&quot;:branch,&quot;name&quot;:&quot;branch&quot;},domProps:{&quot;value&quot;:branch,&quot;checked&quot;:_q(currentBranch,branch)},on:{&quot;change&quot;:function($event){currentBranch=branch}}}),_v(&quot; &quot;),_c('label',{attrs:{&quot;for&quot;:branch}},[_v(_s(branch))])]}),_v(&quot; &quot;),_c('p',[_v(&quot;vuejs/vue@&quot;+_s(currentBranch))]),_v(&quot; &quot;),_c('ul',_l((commits),function(record){return _c('li',[_c('a',{staticClass:&quot;commit&quot;,attrs:{&quot;href&quot;:record.html_url,&quot;target&quot;:&quot;_blank&quot;}},[_v(_s(record.sha.slice(0, 7)))]),_v(&quot;\n          - &quot;),_c('span',{staticClass:&quot;message&quot;},[_v(_s(_f(&quot;truncate&quot;)(record.commit.message)))]),_c('br'),_v(&quot;\n          by &quot;),_c('span',{staticClass:&quot;author&quot;},[_c('a',{attrs:{&quot;href&quot;:record.author.html_url,&quot;target&quot;:&quot;_blank&quot;}},[_v(_s(record.commit.author.name))])]),_v(&quot;\n          at &quot;),_c('span',{staticClass:&quot;date&quot;},[_v(_s(_f(&quot;formatDate&quot;)(record.commit.author.date)))])])}),0)],2)}
})
</code></pre>
<p>with语法执行了当前作用域环境，_c其实就是常见的createElement函数</p>
<h2 id="模板编译完成得到render函数触发beforemounted钩子">模板编译完成，得到render函数，触发beforeMounted钩子</h2>
<h2 id="vnodetoelmmounted钩子触发">vnodeToElm，mounted钩子触发</h2>
<p>函数执行生成的是vnode，再经由<code>vm._update(vnode, hydrating)</code>处理，进入<code>vm.__patch__(vm.$el, vnode, hydrating, false)</code>处理，第一次不会进入<code>patchVnode</code>函数，进入生成分支<code>emptyNodeAt(elm)</code>，生成最外层的父节点，再执行<code>createElm</code>阶段，将当前elm设置成<code>document.createElement(tagName)</code>，再继续进行<code>createChildren</code>，对节点的子节点重复调用<code>createElm</code>，所得的真实dom会通过parent.insertBefore或者parent.appendChild添加到父级真实dom中，最后再移除之前所有的未编译节点，呈现最终的页面（vnode.elm可以看到所有的真实节点）<br>
<code>mountComponent</code>执行完毕，触发mounted钩子，页面上已有真实dom，但是尚未渲染。</p>
<h2 id="nexttick异步任务">nextTick异步任务</h2>
<p><img src="https://chentianyuan.github.io/post-images/1578730088518.png" alt="渲染流程" loading="lazy"><br>
根据浏览器兼容性，promise =&gt; mutationObserver =&gt; setTimeout<br>
微任务可以确保执行时间点会在会在渲染完毕之前，所以在promise =&gt; mutationObserver实现的情况下只会进行一次渲染，而setTimeout(fn, 0)，无法确保执行时间是在渲染后还是渲染之前，所以可能会造成重复渲染，造成跳帧的感觉。</p>
<h2 id="beforeupdate钩子">beforeUpdate钩子</h2>
<p>在mounted之后，data数据发生改变时调用，其有一个专属的组件级的watcher，在数据变化时会被调用before函数，在所有设置的watcher之前，触发beforeUpdate钩子。</p>
<h2 id="updated钩子">updated钩子</h2>
<p>在beforeUpdate钩子之后，对所有的update钩子进行执行<code>nextTick(flushSchedulerQueue) -&gt; callHook(vm, 'update')</code>，如果设置了，则每次在下一次重渲染之前，update钩子会被调用。</p>
<h2 id="beforedestory钩子">beforeDestory钩子</h2>
<p>destory可以通过<code>vm.$destory()</code>来主动触发，其并不会影响页面的展示，但是会清理与其它实例的连接，解绑(<code>vm.deps[i].removeSub()</code>)当前实例的全部指令及事件监听器，然后执行<code>vm.__patch__(vm._vnode, null)</code>，将当前vnode置空，并在其中会触发子组件的destory方法，和mounted一样，destory钩子也是先子组件后父组件</p>
<h2 id="destory钩子">Destory钩子</h2>
<p>所有销毁动作完成之后，触发destroyed钩子，</p>
<h2 id="activated钩子-deactivated钩子">activated钩子 &amp;&amp; deactivated钩子</h2>
<p>涉及keep-alive没有深入研究，大概是组件被复用和缓存组件被销毁时触发</p>
<hr>
<h2 id="总结">总结</h2>
<p>1、js加载并执行，混入必要的属性和方法，声明常用工具类方法<br>
2、实例化，属性合并，初始化解析event事件绑定的方法<br>
3、触发beforeCreate<br>
4、进行数据监测，依赖收集<br>
5、触发craete<br>
6、进行模板编译，将模板转化为render函数<br>
7、触发beforeMounted<br>
8、执行render函数，生成vnode，根据vnode创建真实dom，挂载到指定节点<br>
9、触发mounted钩子<br>
<strong>其他</strong><br>
10、beforeUpdate执行所在的函数在beforeMounted和mounted之前已经生成了，mounted之后的数据变动都会触发beforeUpdate<br>
11、watcher.run()<br>
12、模板更新结束，触发updated钩子<br>
13、beforeDestory组件销毁时触发，也可主动触发，进行事件解绑，依赖移除，vnode清空，执行顺序是先子组件后父组件<br>
14、destory组件销毁完毕触发<br>
15、activated钩子 &amp;&amp; deactivated钩子 缓存组件复用和缓存组件被销毁时触发</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生命关怀的呼唤]]></title>
        <id>https://chentianyuan.github.io/post/sheng-ming-guan-huai-de-hu-huan/</id>
        <link href="https://chentianyuan.github.io/post/sheng-ming-guan-huai-de-hu-huan/">
        </link>
        <updated>2019-12-22T11:49:39.000Z</updated>
        <summary type="html"><![CDATA[<p>在死亡到来的那一天，人人平等，离开这个熟悉又陌生的世界前，我们能带给她们什么？</p>
]]></summary>
        <content type="html"><![CDATA[<p>在死亡到来的那一天，人人平等，离开这个熟悉又陌生的世界前，我们能带给她们什么？</p>
<!-- more -->
<p>上海临终关怀医院，那里住着的多是不治之症的患者，还有一些因为忍受不了病痛的折磨，放弃治疗，平静等待死亡的重病病人。</p>
<p>情况好一些的病人，如果走出医院，她们看起来和常人没什么区别，但是每每发病的夜晚，晚期疾病带来的痛苦和煎熬，只有她们自己知道。</p>
<p>还有些病人，没法说话，无法进食，没法闭上眼睛，没法睡觉，肺部感染带来的高烧在一步一步地销蚀她们的身体，每一次喘气都好像耗尽了她们的所有力气。病房的时钟滴答滴答地走着，像是死神的计时表，不知道哪一秒，死神就挥下了它的镰刀。</p>
<figure data-type="image" tabindex="1"><img src="https://chentianyuan.github.io/post-images/1577017544790.png" alt="death" loading="lazy"></figure>
<p><s>如果时间能够倒转，也许不会是现在的光景。</s></p>
<p>当她失去自主意识，只是本能地呼吸，死亡倒成了一种奢望。</p>
<p>在现代医学已经无能为力的时候，面对这些即将离开的人，我们还能为她们做些什么？</p>
<p>有时候，什么也做不了，做什么，都是徒劳。</p>
<p>关怀生命，不是生命结束前的一个口号，而是生者的呼唤，一种生活的态度，一种不让那一天到来留下遗憾的祈盼。</p>
<p>太负能量了，再也不写这种了。</p>
]]></content>
    </entry>
</feed>