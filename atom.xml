<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chentianyuan.github.io</id>
    <title>City Corner</title>
    <updated>2019-12-28T03:13:40.119Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chentianyuan.github.io"/>
    <link rel="self" href="https://chentianyuan.github.io/atom.xml"/>
    <subtitle>脚踏实地 仰望星空</subtitle>
    <logo>https://chentianyuan.github.io/images/avatar.png</logo>
    <icon>https://chentianyuan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, City Corner</rights>
    <entry>
        <title type="html"><![CDATA[生命关怀的呼唤]]></title>
        <id>https://chentianyuan.github.io/post/sheng-ming-guan-huai-de-hu-huan</id>
        <link href="https://chentianyuan.github.io/post/sheng-ming-guan-huai-de-hu-huan">
        </link>
        <updated>2019-12-22T11:49:39.000Z</updated>
        <summary type="html"><![CDATA[<p>在死亡到来的那一天，人人平等，离开这个熟悉又陌生的世界前，我们能带给她们什么？</p>
]]></summary>
        <content type="html"><![CDATA[<p>在死亡到来的那一天，人人平等，离开这个熟悉又陌生的世界前，我们能带给她们什么？</p>
<!-- more -->
<p>上海临终关怀医院，那里住着的多是不治之症的患者，还有一些因为忍受不了病痛的折磨，放弃治疗，平静等待死亡的重病病人。</p>
<p>情况好一些的病人，如果走出医院，她们看起来和常人没什么区别，但是每每发病的夜晚，晚期疾病带来的痛苦和煎熬，只有她们自己知道。</p>
<p>还有些病人，没法说话，无法进食，没法闭上眼睛，没法睡觉，肺部感染带来的高烧在一步一步地销蚀她们的身体，每一次喘气都好像耗尽了她们的所有力气。病房的时钟滴答滴答地走着，像是死神的计时表，不知道哪一秒，死神就挥下了它的镰刀。</p>
<figure data-type="image" tabindex="1"><img src="https://chentianyuan.github.io/post-images/1577017544790.png" alt="death"></figure>
<p><s>如果时间能够倒转，也许不会是现在的光景。</s></p>
<p>当她失去自主意识，只是本能地呼吸，死亡倒成了一种奢望。</p>
<p>在现代医学已经无能为力的时候，面对这些即将离开的人，我们还能为她们做些什么？</p>
<p>有时候，什么也做不了，做什么，都是徒劳。</p>
<p>关怀生命，不是生命结束前的一个口号，而是生者的呼唤，一种生活的态度，一种不让那一天到来留下遗憾的祈盼。</p>
<p>太负能量了，再也不写这种了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深度优先遍历和广度优先遍历]]></title>
        <id>https://chentianyuan.github.io/post/shen-du-you-xian-bian-li-he-guang-du-you-xian-bian-li</id>
        <link href="https://chentianyuan.github.io/post/shen-du-you-xian-bian-li-he-guang-du-you-xian-bian-li">
        </link>
        <updated>2019-12-04T13:17:43.000Z</updated>
        <summary type="html"><![CDATA[<p>DFS VS BFS</p>
]]></summary>
        <content type="html"><![CDATA[<p>DFS VS BFS</p>
<!-- more -->
<h3 id="题目">题目</h3>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<pre><code class="language-javascript">// DFS 解题
var rightSideView = function(root) {
    let resultList = []
    let i = 0
    let dfs = function (Node, i) {
      // 该节点不存在
      if (!Node) {
        return
      }
      resultList[i] = resultList[i] || []
      resultList[i].push(Node.val)
      dfs(Node.left, i + 1)
      dfs(Node.right, i + 1)
    }
    dfs(root, i)
    return resultList.map(result =&gt; result[result.length - 1])
};
// 优先左子树，再遍历右子树，每次递归深度+1
</code></pre>
<pre><code class="language-javascript">// BFS 解题
var rightSideView = function(root) {
    let resultList = []
    let j = -1
    let bfs = function (Nodes) {
      while (Nodes.length &gt; 0) {
        j++
        // 该节点不存在
        if (!Nodes.length) {
          return
        }
        let length = Nodes.length
        for (let i = 0; i &lt; length; i++) {
          let Node = Nodes.shift()
          resultList[j] = resultList[j] || []
          resultList[j].push(Node.val)
          if (Node.left) Nodes.push(Node.left)
          if (Node.right) Nodes.push(Node.right)
        }
      }
    }
    if (!root) return []
    bfs([root])
    return resultList.map(result =&gt; result[result.length - 1])
};
// 广度优先遍历的核心就是queues
// 队列存储左右节点，然后进入下一次循环，循环原始队列，队列头出队列，将左子树右子树分别重新插入队列，最后的到的类似[left.left, left.right, right.left, right.right]进行我们想要的操作
</code></pre>
<p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">力扣原题</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器工作原理及实践]]></title>
        <id>https://chentianyuan.github.io/post/liu-lan-qi-gong-zuo-yuan-li-ji-shi-jian</id>
        <link href="https://chentianyuan.github.io/post/liu-lan-qi-gong-zuo-yuan-li-ji-shi-jian">
        </link>
        <updated>2019-11-08T10:51:13.000Z</updated>
        <summary type="html"><![CDATA[<p>极客时间课程笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>极客时间课程笔记</p>
<!-- more -->
<h2 id="0-chrome架构">0、chrome架构</h2>
<p>q: 为什么chrome打开一个页面，会启动四个进程？<br>
a: 浏览器主进程、插件进程、网络进程、渲染进程、GPU进程(GPU进程用于3D绘制，在2d场景下渲染进程就可以)存在进程隔离，相比在ie6中使用单进程架构，任意一个进程崩溃都会导致浏览器的崩溃，chrome的多进程架构很好的解决了这个问题。而且每个进程都在沙箱中运行，也解决了插件的安全问题。</p>
<h2 id="1-tcp协议">1、TCP协议</h2>
<p>q: TCP协议为什么能完整地传输页面？<br>
a: 首先，了解一下过程，TCP和UDP都作为传输层的协议，TCP和UDP都需要在传输层向数据包中添加端口，然后网络层的ip协议添加ip端口。UDP为无连接的传输协议，无法组装数据包，而且容易丢包，常用于视频传输，或者音频传输。而TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，相对于UDP，有丢包重传和数据包排序（数据包按顺序组装成完整文件）的特点。</p>
<h2 id="2-http请求流程">2、http请求流程</h2>
<figure data-type="image" tabindex="1"><img src="https://chentianyuan.github.io/post-images/1573212377705.png" alt="部分流程"></figure>
<h2 id="3-从输入一个url到显示页面发生了什么">3、从输入一个url到显示页面发生了什么？</h2>
<p>（以前总是想把每个细节都说的很完整，但是在面试中，这个的关键是流程，不是细节流程，大可等面试官下一个问题）</p>
<ol>
<li>用户输入url，按下回车键</li>
<li>浏览器检查url，组装协议</li>
<li>浏览器进程通过ipc通知网络进程</li>
<li>网络进程接收到url后检查本地缓存，是则直接拿出缓存给浏览器进程，否则<br>
4.1 dns解析，拿到ip和端口（80或443）<br>
4.2 通过TLS协议，建立安全连接<br>
4.3 建立TCP连接<br>
4.4 TCP、IP协议组装数据包，发送请求<br>
4.4 网络进程接收响应信息，并解析响应内容 （略去了304的流程）</li>
<li>网络进程通知浏览器进程，浏览器进程决定是否需要重新开启渲染进程</li>
<li>浏览器进程通知渲染进程，渲染进程和网络进程建立管道，开始接收数据</li>
<li>加载css，解析html，生成cssom和domTree，进而生成render tree，如遇到js则阻塞渲染和解析，js的加载不一定阻塞，最后js执行完毕，进行layout，最后进行paint</li>
<li>渲染进程通知，浏览器进程更新状态，icon、前进后退状态、安全等</li>
</ol>
<h2 id="4-渲染进程">4、渲染进程</h2>
<p>浏览器无法直接渲染html文件，需要经历以下步骤<br>
dom tree =&gt; document<br>
cssom =&gt; document.stylesheet<br>
合并得到layoutTree <strong>（布局树）</strong><br>
得到布局树之后，还不能直接绘制，浏览器的页面实际上被分为了很多图层**（元素有了层叠上下文属性或者需要裁剪都会形成新的图层）**，所有图层叠加得到了最后的页面<br>
渲染进程绘制图层<br>
GPU进程进行栅格化操作，为视口区域生成位图，保存在GPU内存中<br>
最后通知浏览器进程，展示页面</p>
<h2 id="5-浏览器内的js执行">5、浏览器内的js执行</h2>
<p>全局代码执行首先会编译代码，然后创建执行上下文和将代码分别在变量环境和词法环境执行<br>
在碰到function执行时会创建新的上下文和新的词法环境<br>
同eval执行wei'd'wa<br>
<img src="https://chentianyuan.github.io/post-images/1573476515573.png" alt="执行上下文"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https协议详解]]></title>
        <id>https://chentianyuan.github.io/post/https-xie-yi-xiang-jie</id>
        <link href="https://chentianyuan.github.io/post/https-xie-yi-xiang-jie">
        </link>
        <updated>2019-10-30T12:11:46.000Z</updated>
        <summary type="html"><![CDATA[<p>最后一次，理解https协议</p>
]]></summary>
        <content type="html"><![CDATA[<p>最后一次，理解https协议</p>
<!-- more -->
<h3 id="why">why？</h3>
<p>首先要明确的是https是为了解决什么问题<br>
http请求的所有数据都是明文传输，在网络中无异于裸奔，会出现以下几个问题</p>
<ol>
<li>数据窃听</li>
<li>假装真实客户端向恶意攻击服务端</li>
<li>假装服务端返回假数据<br>
https在应用层和传输层中间增加了SSL层，SSL可以理解为CA证书的作用（防止中间人篡改）<br>
然后使用TLS协议通信，生成对称密匙后采用对称加密，（防止中间人窃取）保证了数据的安全性</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://chentianyuan.github.io/post-images/1572438323964.JPG" alt="Jesus"></figure>
<h3 id="how">how？</h3>
<p>流程详解</p>
<ol>
<li>TCP链接建立之后</li>
<li>客户端向服务端443端口发起请求，携带random1和加密方法列表，TLS第一步</li>
<li>服务端返回CA证书携带服务端公匙和random2</li>
<li>客户端拿到CA证书和公匙，和本地CA证书对比校验证书有效性（这里防止中间人篡改随机数）</li>
<li>验证有效后，客户端生成random3，这里做了两件事，第一自己使用random1，random2，random3生成对称密匙sercet，第二使用服务端给出的公匙加密random3，返回给服务端（非对称加密防止中间人窃取）</li>
<li>服务端拿到加密后的random3，使用私匙解密，截止目前为止，客户端和服务端都知道random1，random2，random3，服务端也生成对称密匙sercet，得到双方都知道的对称密匙</li>
<li>最后，双方使用对称密匙加密数据进行通信</li>
</ol>
<p>总结：<br>
利用CA证书，加密先使用非对称加解密，再使用对称密匙加解密，解决了http带来的窃听和请求伪造的问题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[commonjs和ES6模块的区别]]></title>
        <id>https://chentianyuan.github.io/post/commonjs-he-es6-mo-kuai-de-qu-bie</id>
        <link href="https://chentianyuan.github.io/post/commonjs-he-es6-mo-kuai-de-qu-bie">
        </link>
        <updated>2019-10-26T03:10:51.000Z</updated>
        <summary type="html"><![CDATA[<p>对比commonjs和ES6，了解前端模块化机制</p>
]]></summary>
        <content type="html"><![CDATA[<p>对比commonjs和ES6，了解前端模块化机制</p>
<!-- more -->
<h2 id="commonjs-规范">commonjs 规范</h2>
<p>1、commonjs应用于nodejs模块化管理，是nodejs实现的一套模块化机制。</p>
<p>2、commonjs属于动态编译，运行时才确定加载模块，输入时需查找对象属性，所以无法做到按需加载，总是引入整个模块对象。</p>
<p>3、模块导出的是值得拷贝各个引用互不影响。</p>
<p>4、this指向当前模块。</p>
<h2 id="es6-module">ES6 module</h2>
<p>1、es6的模块化可以应用在浏览器和node服务端。</p>
<p>2、es6模块的设计思想，是尽量静态化，在编译时就确定模块的依赖关系以及输入和输出的变量，其静态编译使得可以编译时就确认要使用的模块中的内容可做按需加载。</p>
<p>3、模块导出的是值得引用，若其中引用被修改，下次引用时得到的是修改后的值。</p>
<p>4、this指向undefined。</p>
<pre><code class="language-javascript">import zw from './a' 
import('./b').then(res =&gt; {
  console.log(zw) // b模块修改后的zw的值
})
</code></pre>
<h2 id="扩展">扩展</h2>
<p>webpack打包时默认会模拟一套类commonjs规范的加载器，如果有使用spliteChunk抽离出runtime的话，可以查阅相关代码，所以webpack默认是无法做到按需加载的，像<code>import { Button } from 'Antd'</code>这样的语句会打包Antd提供的所有模块，并使用其中的babel模块，我们可以引入<code>babel-plugin-component</code>或者<code>babel-plugin-import</code>来解决这个问题。</p>
<blockquote>
<p>babel 能提前将 es6 的 import 等模块关键字转换成 commonjs 的规范。这样 webpack 就无需再做处理，直接使用 webpack 运行时定义的 <strong>webpack_require</strong> 处理。而babel-plugin-component就做了一件事，将 import { Button } from 'antd' 转换成了 import Button from 'antd/lib/button'，这样即便转成commonjs规范也只引入了一个库文件</p>
</blockquote>
<p>深夜打卡<br>
<s>水了一篇，开心٩(๑❛ᴗ❛๑)۶</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[某大厂前端二面题]]></title>
        <id>https://chentianyuan.github.io/post/mou-da-han-qian-duan-er-mian-ti</id>
        <link href="https://chentianyuan.github.io/post/mou-da-han-qian-duan-er-mian-ti">
        </link>
        <updated>2019-10-26T03:09:42.000Z</updated>
        <summary type="html"><![CDATA[<p>杭州某大厂前端面试题总结，过于浮躁，损失了一次进大厂的机会🤦‍♂</p>
]]></summary>
        <content type="html"><![CDATA[<p>杭州某大厂前端面试题总结，过于浮躁，损失了一次进大厂的机会🤦‍♂</p>
<!-- more -->
<h2 id="1-重启nginx需要什么权限">1、重启nginx需要什么权限</h2>
<p>linux的文件目录有所有者和组的概念，对一个目录来说所有人分为三种，<strong>ugo</strong>，u为此目录拥有者，g为group，o为other，还有一个a，包含以上三者。若是目录的所有者，或者此时的用户在此目录的用户组内，则有该用户组所拥有的所有权限。</p>
<h3 id="一些常识">一些常识</h3>
<p>十位权限含义 第一位d代表目录-代表文件，其后分别为ugo的三种权限，drwxrwxrwx 代表此目录所有人皆可读写执行。</p>
<pre><code class="language-javascript">chmod u=rw,g=---,o--- // 给user读写权限，group内的人和其他人没有任何权限
chmod a=rwx // 给所有人读写执行权限
chmod 777 file // 其实 就是 chmod a=rwx file  --&gt; 4 + 2 + 1
chmod u+x file // 就是给拥有者执行权限
// 若文件没有x权限，仍可通过有权限的其他，比如sh，node，python命令来执行某个文件，若其有x权限，那么直接在文件中标明要使用的bash命令，然后 ./文件名 执行即可
</code></pre>
<p>每个文件都有rwx（read/writer/excute)读写操作权限，想要修改一个nginx配置文件并执行，看如何修改，若是直接删除替换，则仅需rx权限，若通过vim这种，还需要关注文件内容，还需额外r读权限。（另外还有一个 - 即代表无权限），*nginx的执行脚本所在的bin目录一般只有root有权限。*所以应当是root权限吧。</p>
<h2 id="2-单核机器多进程构建时是否有效">2、单核机器多进程构建时是否有效</h2>
<p>答案是无效的，而且效率会变低。。。</p>
<p>webpack使用happypack开启多进程构建，在单核机器上并没有效果。单核cpu从宏观上看是为多进程服务的，实际上是每个进程轮流使用一段时间片，即便开1w个进程速度也不会变快，而且还有进程的上下文切换开销，速度反而会变慢，而且一旦其中有一个进程计算量大卡住，其他进程也会进入假死状态，无法继续执行任务。</p>
<p>机（智）智（障）的我答了有效。</p>
<h2 id="3-实现类似node的eventemitter模块">3、实现类似node的EventEmitter模块</h2>
<p>拿到面试官的电脑，我已经满脑子的骚操作决定扳回一局，结果</p>
<pre><code>// 一顿分析猛如虎，一看战绩0杠5
class event {
  constuctor () {
    this.eventLib = {}
  }
  on (name, callback) {
    if (Array.isArray(this.eventLib[name])) {
      this.eventLib[name].push(callback)
    } else {
      this.eventLib[name] = [callback]
    }
  }
  emit (name) {
    if (!this.eventLib[name]) reutrn
    for (let cb of this.eventLib[name] ) {
      cb()
    }
  }
}
let e = new event()
e.on('take', function () { console.log(123) })
e.on('take', async function () {
  await new Promsie (r =&gt; {
     console.log(456) 
  })
})
e.emit('task')
// 并不知道这样写是不是面试官最后想要的，希望有评论区大神出现
</code></pre>
<h2 id="4-ssr相对java直出页面模板速度有变快吗">4、SSR相对java直出页面模板速度有变快吗</h2>
<p>为了表现的我们做的SSR有用，我毫不犹豫地回答有。</p>
<p>其实java直出页面和node直出是一样的模式，仅仅语言不同（的确老的java直出的模板有些是异步数据，整个页面呈现速度没有node做了页面缓存来得快）但是就模式上来说，单线程的node对上java根本没有优势，速度的确不会有提升，甚至可能变慢（抛弃代码及策略优化的影响），相对java直出模板SSR带来的好处更多的是前后端解耦，在保持SEO，避免白屏的前提下，享受MVVM带来的便捷开发，node减轻服务端压力，减少后端工作量等等...</p>
<h2 id="5-面试总结">5、面试总结</h2>
<p>少在简历上挖坑。</p>
<p>少吹牛比多看书。</p>
<p>talk is cheap，show me your thinking。</p>
<p><em>还有一些问题文中没有提及，待总结</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Session Token]]></title>
        <id>https://chentianyuan.github.io/post/xiang-jie-session-he-token</id>
        <link href="https://chentianyuan.github.io/post/xiang-jie-session-he-token">
        </link>
        <updated>2019-10-05T11:50:52.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>这是一篇对比session和token登录机制的文章</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>这是一篇对比session和token登录机制的文章</strong></p>
<!-- more -->
<h2 id="question">question:</h2>
<p>1、为什么需要session和token？<br>
因为http请求是无状态的，为了标识多个请求之间的联系，必须引入一些手段和工具来标记他们，所以需要引入session和token<br>
最常见的就是标识用户的登录状态</p>
<h2 id="流程">流程：</h2>
<p>1、客户端发起登录请求</p>
<h3 id="session和cookie">Session和Cookie</h3>
<p>2、服务端验证登录信息通过，生成session_id作为hash映射用户信息session<br>
3、在响应体中加入set-cookie字段<br>
4、客户端接收到响应，根据set-cookie，自动种下session_id<br>
5、客户端再次请求，自动带上session_id，服务端根据session_id拿到用户信息和登录状态，再返回客户端想要的用户数据</p>
<h3 id="token">Token</h3>
<p>2、服务端验证登录信息通过，根据header，payload生成token（header.payload.signnature）（signnature也叫签名，其实是base64编码的header+'.'+base64编码的payload，再根据私匙加密一下得到的）<br>
3、客户端拿到token后存储到storage内，下次请求，再主动塞入header里<br>
4、服务端拿到header里的token，取出header和payload，用私匙重新加密，再和header里的token的signnature进行对比，如果正确则验证通过，证明用户是登录状态<br>
5、从payload中拿到用户id，查询并返回客户端想要的用户数据</p>
<h4 id="优缺点">优缺点</h4>
<p>1、token天然就有预防CSRF攻击的功能，cookie中存储的session在有post表单提交的攻击网站上会带上目标网站的所有cookie信息，如果刚好最近登录过，那么请求是会成功的<br>
2、token的校验比较耗时，可能会影响接口返回速度<br>
3、在负载均衡的情况下，session无法做到多台机器共享，必须要借助一个共用服务<br>
4、session会占用服务端宝贵的内存资源，带来内存压力</p>
<h4 id="如何清除登录状态">如何清除登录状态</h4>
<p>session机制中，下发sessionId的同时会带一个expires或者maxAge，服务端需要记录下发时间，下次请求进来时对查到的sessionId对应的session的时效性进行校验，如果超时，则清除server端存储的信息，并告知客户端登录超时。<br>
token无法做到完美清除<br>
1、可以在token的payload位置存储一个时间戳，然后校验合法性时同时校验token是否超时。用户主动登出时，重新下发一个超时的token挤掉原先的token。<br>
2、在user表中加一个时间戳字段，查询用户信息时同时对比token是否过期。</p>
<h4 id="再讲一个题外话为什么token需要用base64编码呢">再讲一个题外话，为什么token需要用base64编码呢❓</h4>
<p>base64最早是通用的邮件传输协议中的转码方式，原先的邮件传输协议只支持ASCII码传递，而ascii码的128～255之间的值是不可见字符，因此，如果要传输二进制文件是无法实现的，所以base64就是用来将二进制文件编码为只包含ASCII可见字符的内容再用来传输的，虽然尺寸会增加三分之一（在base64编码中，需要2的6次方位来表示字符，所以每6个比特代表一个字节。假如要传输Man三个字符，base64编码后是TWFu，文件尺寸是原来的3分之4），但是得到了更好的兼容性。<br>
<a href="https://zh.wikipedia.org/wiki/Base64">base64</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://chentianyuan.github.io/post/hello-gridea</id>
        <link href="https://chentianyuan.github.io/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>