<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chentianyuan.github.io</id>
    <title>City Corner</title>
    <updated>2020-03-24T14:47:27.724Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chentianyuan.github.io"/>
    <link rel="self" href="https://chentianyuan.github.io/atom.xml"/>
    <subtitle>脚踏实地 仰望星空</subtitle>
    <logo>https://chentianyuan.github.io/images/avatar.png</logo>
    <icon>https://chentianyuan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, City Corner</rights>
    <entry>
        <title type="html"><![CDATA[一天一道算法题系列]]></title>
        <id>https://chentianyuan.github.io/post/yi-tian-yi-dao-suan-fa-ti-xi-lie/</id>
        <link href="https://chentianyuan.github.io/post/yi-tian-yi-dao-suan-fa-ti-xi-lie/">
        </link>
        <updated>2020-03-09T15:02:13.000Z</updated>
        <summary type="html"><![CDATA[<p>自知算法薄弱，做不到一步登天，那就脚踏实地，聚沙成塔。<br>
不积跬步无以至千里，不积小流无以成江河。</p>
]]></summary>
        <content type="html"><![CDATA[<p>自知算法薄弱，做不到一步登天，那就脚踏实地，聚沙成塔。<br>
不积跬步无以至千里，不积小流无以成江河。</p>
<!-- more -->
<h1 id="20200309">20200309</h1>
<p><strong>题型：树的广度优先遍历</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcokigrjddj31b00pk755.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
var levelOrderBottom = function(root) {
  if (!root) return []
  let result = []
  let depth = 0
  let queue = []
  queue.push(root)
  while (queue.length) {
    result[depth] = []
    let length = queue.length
    for (let i = 0; i &lt; length; i++) {
      queue[i].val !== null &amp;&amp; result[depth].push(queue[i].val)
      if (queue[i].left) queue.push(queue[i].left)
      if (queue[i].right) queue.push(queue[i].right)
    }
    queue.splice(0, length)
    depth++
  }
  return result.reverse()
};
</code></pre>
<p>思路：广度优先遍历需要借助队列，每一层结束了就splice掉，一层一层向下，最后翻转一下就好。<br>
时间复杂度：O(n)</p>
<h1 id="20200310">20200310</h1>
<p><strong>题型：树的深度优先遍历</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcp7mcpe93j31bi0jwdgo.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
var diameterOfBinaryTree = function(root) {
  if (!root) return 0
  let result = 0
  function getMax (root) {
    result = Math.max(result, getDeep(root.left) + getDeep(root.right))
    if (root.left) getMax(root.left)
    if (root.right) getMax(root.right)
    return result
  }
  function getDeep (node, depth = 0) {
    if (node) {
      depth++
      return Math.max(getDeep(node.left, depth), getDeep(node.right, depth))
    } else {
      return depth
    }
  }
  return getMax(root)
};
</code></pre>
<p>思路：方向是对的，深度优先遍历，但是这边有个坑，不能直接两边最大深度相加，因为这个直径可能根本就不经过根节点，所以要把每个节点都当做根节点进行一次递归求两边最大深度与当前result的大值。</p>
<h1 id="20200311">20200311</h1>
<p><strong>题型：数学、双向链表</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcqeh1o63nj312q0u0763.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} A
 * @return {boolean}
 */
var canThreePartsEqualSum = function(A) {
  let sum = getSum(A)
  let left = []
  let right = []
  if (sum % 3 !== 0) return false
  for (let i = 0; i &lt; A.length - 1; i++) {
    left.push(A[i])
    if (getSum(left) === sum / 3) {
      for (let j = A.length - 1; j &gt; i + 1; j--) {
        right.push(A[j])
        if (getSum(right) === sum / 3) {
          return true
        }
      }
      return false
    }
  }
  return false
};

function getSum (arr) {
  return arr.reduce((a, b) =&gt; (a + b), 0)
}
</code></pre>
<p>思路：最重要的是，数组可以分成三段，每段和相同，那么他们一定等于<code>getSum(A) / 3</code>，剩下的就是两边往中间遍历而已。</p>
<h1 id="20200312">20200312</h1>
<p>** 题型：数学 **<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcrld0bogcj314y0u0dh9.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {string} str1
 * @param {string} str2
 * @return {string}
 */
var gcdOfStrings = function(str1, str2) {
  if (str1 === str2) return str1
  if (str1.length &lt; str2.length) {
    let temp = str2
    str2 = str1
    str1 = temp
  }
  let result = ''
  for (let i = 1; i &lt;= str2.length; i++) {
    let temp = str2.slice(0, i)
    if (str1.split(temp).join('') === '' &amp;&amp; str2.split(temp).join('') === '') {
      result = temp
    }
  }
  return result
};
</code></pre>
<p>思路：1、最简单的枚举，从长度1到较小字符串长度一个一个试，2、欧几里得公式，求最大公约数，然后从较小的字符串里取这个长度</p>
<h1 id="20200313">20200313</h1>
<p>** 题型：哈希表 **<br>
169. 多数元素</p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  let timeMap = new Map()
  if (nums.length === 1) return nums[0]
  for (let i = 0; i &lt; nums.length; i++) {
    if (timeMap.has(nums[i])) {
      if (timeMap.get(nums[i]) + 1 &gt; Math.floor(nums.length / 2)) {
        return nums[i]
      }
      timeMap.set(nums[i], timeMap.get(nums[i]) + 1)
    } else {
      timeMap.set(nums[i], 1)
    }
  }
};
</code></pre>
<p>思路：hashmap存储元素出现的次数，比较简单</p>
<h1 id="20200314">20200314</h1>
<p>** 题型：动态规划 **<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gctu5hfdfrj31bq0jkmya.jpg" alt="最长上升子序列" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  let maxUpList = []
  for (let i = 0; i  &lt; nums.length; i++) {
    if (!maxUpList.length) {
      maxUpList.push(nums[i])
    } else if (maxUpList.slice(-1) &lt; nums[i]) {
      maxUpList.push(nums[i])
    } else {
      let index = maxUpList.findIndex(item =&gt; item &gt;= nums[i])
      maxUpList[index] = nums[i]
    }
  }
  return maxUpList.length
};

// 动态规划版本
var lengthOfLIS = function(nums) {
  let dp = new Array(nums.length).fill(1)
  for (let i = 1; i &lt; nums.length; i++) {
    for (let j = 0; j &lt; i; j++) {
      if (nums[j] &lt; nums[i]) {
        // 状态转移方程
        dp[i] = Math.max(dp[j] + 1, dp[i])
      }
    }
  }
  return dp.reduce((pre, cur) =&gt; Math.max(pre, cur), 0)
};
</code></pre>
<p>思路：最开始的思路就是对整个数组进行一次遍历，往后插入大值，小值可以替换前面的值，因为遍历还是线性的，所以时间复杂度还是O(n^2)<br>
从动态规划的角度来看，dp[j] = dp[i] + 1，只要满足j位置的值大于前面i位置的值，那么就可以和i位置的最长上升子序列组成一个更长的最长上升子序列，因为每次到j时都得变量一遍前面i个位置的值，所以时间复杂度还是O(n^2)，使用的数组长度小于等于原数组长度，空间复杂度O(n)</p>
<h1 id="20200316">20200316</h1>
<p>** 题型：空间换取时间 **<br>
<a href="https://leetcode-cn.com/problems/compress-string-lcci/">试题 01.06. 字符串压缩</a><br>
思路：用两个组分别存储重复字符和重复字符的长度，最后进行一次比较即可</p>
<h1 id="20200317">20200317</h1>
<p>** 题型：哈希表计数 **<br>
<a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/">1160. 拼写单词</a></p>
<pre><code class="language-javascript">var countCharacters = function(words, chars) {
  let map = {}
  for (let i = 0; i &lt; chars.length; i++) {
    if (!map[chars[i]]) {
      map[chars[i]] = 1
    } else {
      map[chars[i]] = map[chars[i]] + 1
    }
  }
  return words.reduce((result, cur) =&gt; {
    let word = {}
    for (let i = 0; i &lt; cur.length; i++) {
      if (word[cur[i]]) {
        word[cur[i]] = word[cur[i]] + 1
      } else {
        word[cur[i]] = 1
      }
    }
    if (Object.keys(word).every(key =&gt; map[key] &gt;= word[key])) {
      return result + cur.length
    } else {
      return result
    }
  }, 0)
};
</code></pre>
<h1 id="20200318">20200318</h1>
<p>** 题型：数学 **<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyh1i751cj312q0u0761.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} rec1
 * @param {number[]} rec2
 * @return {boolean}
 */
var isRectangleOverlap = function(rec1, rec2) {
  let [x1, y1, x2, y2] = rec1
  let [x3, y3, x4, y4] = rec2
  return hasjiaoji([x1, x2], [x3, x4]) &amp;&amp; hasjiaoji([y1, y2], [y3, y4])
};

function hasjiaoji (arr1, arr2) {
  let da1 = Math.max(arr1[0], arr1[1])
  let da2 = Math.max(arr2[0], arr2[1])
  let xiao1 = Math.min(arr1[0], arr1[1])
  let xiao2 = Math.min(arr2[0], arr2[1])
  if (
    da1 &lt;= xiao2 || xiao1 &gt;= da2
  ) {
    return false
  } else {
    return true
  }
}
</code></pre>
<p>思路：看x轴和y轴是否两两相交，如果是则必有面积重叠</p>
<h1 id="20200319">20200319</h1>
<p>** 题型：哈希表 || Set **<br>
<a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></p>
<pre><code class="language-javascript">/**
 * @param {string} s
 * @return {number}
 */
var longestPalindrome = function(s) {
  let map = {}
  for (let i = 0; i &lt; s.length; i++) {
    if (map[s[i]]) {
      map[s[i]] = map[s[i]] + 1
    } else {
      map[s[i]] = 1
    }
  }
  let hasSingle = false
  return Object.values(map).reduce((result, cur) =&gt; {
    if (cur % 2 !== 0 &amp;&amp; !hasSingle) {
      hasSingle = true
    }
    return result + (Math.floor(cur / 2) * 2)
  }, 0) + (hasSingle ? 1 : 0)
};
</code></pre>
<p>思路：<br>
1、能组成回文则出现偶数次，若有一个字符出现奇数次，回文长度加一<br>
2、使用Set数据结构，set.has，则长度加2，并set.delete该值，若不存在则set.add</p>
<h1 id="20200322前两天太忙了今天补上之后继续因为代码可以到力扣看这边简单题只写思路和截图">20200322（前两天太忙了，今天补上之后继续，因为代码可以到力扣看，这边简单题只写思路和截图）</h1>
<p><strong>题型：hash表</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd31jfoh24j315g0rcabe.jpg" alt="" loading="lazy"><br>
思路：先排序，重复出现的元素仅需要比上一个出现的非重复元素大1即可，累加相差的值就是要move的值<br>
<strong>题型：数学</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd33erq644j315a0p475p.jpg" alt="" loading="lazy"><br>
思路：非常硬核的一道题，暴力求解会超时。由于数组中最大的值为1e9也就是10的9次方，因为2^30&lt; 10e9 &lt;2^31也就是说至少需要31位2进制才可以表示这个二进制数，通过num.toString(2)转为二进制之后，遍历每一位上的0和1的个数并统计，当前位汉明距离（任意两个数二进制当前位不同的数量即01组合的个数）等于count[0]*count[1]个，最后31位统一累加，时间复杂度是O(n)，空间复杂度O(1)。</p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var totalHammingDistance = function(nums) {
  let result = 0
  let maxBit = 31 // 最大32位
  nums = nums.map(num =&gt; num.toString(2))
  for (let i = 0; i &lt; maxBit; i++) {
    let count = {
      '0': 0,
      '1': 0
    }
    for (let j = 0; j &lt; nums.length; j++) {
      let cur = nums[j]
      count[+cur[cur.length - i - 1] ? '1' : '0']++
    }
    result += count[0] * count[1]
  }
  return result
};
</code></pre>
<h1 id="20200323">20200323</h1>
<p><strong>题型：链表</strong><br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd4aa3oh6bj31410u0jt8.jpg" alt="" loading="lazy"><br>
思路：<br>
1、单指针两次遍历，第一次记录长度，第二次访问到中间长度时返回节点<br>
2、快慢指针，快指针一次移动两格，慢指针一次移动一格，快指针到达链表尾部时，慢指针也就在中间了~</p>
<h1 id="20200324">20200324</h1>
<p>** 题型：动态规划**<br>
<img src="https://tva1.sinaimg.cn/large/00831rSTly1gd5eehkstfj313b0u0jt9.jpg" alt="" loading="lazy"></p>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number}
 */
var massage = function(nums) {
  let dp = []
  dp[0] = nums[0]
  dp[1] = Math.max(nums[1], nums[0])
  for (let i = 2; i &lt; nums.length; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
  }
  return dp[nums.length - 1] || 0
};
</code></pre>
<p>每次做到动态规划的题总是知道这道题要用动态规划，可是就是做不出来。。<br>
思路：<code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])</code>。每次中间需要间隔，三个一组，但是不是0,3到3,6，而是0,3到1,4，像滑动窗口一样划过去，计算每个点位的最大值，最后返回dp[i]即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[组件库设计思路]]></title>
        <id>https://chentianyuan.github.io/post/zu-jian-ku-she-ji-si-lu/</id>
        <link href="https://chentianyuan.github.io/post/zu-jian-ku-she-ji-si-lu/">
        </link>
        <updated>2020-02-24T06:22:23.000Z</updated>
        <summary type="html"><![CDATA[<p>去年参与了部分公司的组件库建设，md-loader只是一部分，从全局的角度梳理一下整个组件库的设计流程</p>
]]></summary>
        <content type="html"><![CDATA[<p>去年参与了部分公司的组件库建设，md-loader只是一部分，从全局的角度梳理一下整个组件库的设计流程</p>
<!-- more -->
<h1 id="1-文档的归属">1、文档的归属</h1>
<p>一份优质的文档是一个成功的组件库的基础，element-ui的官网文档是经受了无数厂商的考验的，因此md-loader已经是很好的实践。另一个值得权衡的问题是，文档是新开一个项目还是就放在组件库的项目里？<br>
如果放在项目里，组件库一大，项目会略显臃肿，并且每次跑项目都需要把组件进行重新编译，速度堪忧。而如果分离出一个新的项目，则享受不到开发时热更新的遍历，需要把打包文件频繁输出，才能实时看到组件的效果，而且另起一个工程也是有成本的，需要安装两次通用的依赖。<br>
综上：从遍历性的角度来看，还是放在一个项目内会方便得多，除非你的目标是做一个大而美的业界组件库，而不是为了业务需要快速迭代的产物（然而没有资本支撑，估计也没人愿意做这么一套东西）</p>
<h1 id="2-打包配置">2、打包配置</h1>
<h3 id="21-按需打包配置">2.1 按需打包配置</h3>
<p>为了按需加载引入，我们常用<code>babel-plugin-component</code>或<code>babel-plugin-syntax-dynamic-import</code>这两个babel插件来使得<code>import { WandUploader } from @weiyi/wand-ui</code>变成<code>import /node_modules/@weiyi/wand-ui/libaryName/uploader/index.js</code>+组件css引入（通用css会从libaryName下引入）来实现。因此我们要将每个组件作为单独入口打包出index.js和组件的css，组件css可以使用<code>MiniCssExtractPlugin</code>来实现拆分。另外，配置中需要外置化vue，否则vue会被打包进入组件bundle。</p>
<pre><code class="language-javascript">externals: [
    {
        vue: {
        root: 'Vue',
        commonjs: 'vue',
        commonjs2: 'vue',
        amd: 'vue'
        },
        'vue-property-decorator': 'vue-property-decorator'
    }
]
</code></pre>
<h3 id="22-全量打包配置">2.2 全量打包配置</h3>
<p>当我们全量引入某个vue组件库时，在入口处直接使用<code>Vue.use(WandUi)</code>来导入非常方便，因此，我们的全量打包入口文件也应当导出一个install函数，来支持这种插件式引入。</p>
<pre><code class="language-javascript">export default {
  install: (Vue: VueConstructor) =&gt; {
    components.forEach(comp =&gt; {
      if (comp.install) {
          // 针对支持插件式调用的组件，还需要进行一次插件注册
        Vue.use(comp as any)
      } else {
          // 全局组件注册
        Vue.component((comp as any).options.name, comp)
      }
    })
  }
}
</code></pre>
<h3 id="3-便捷组件生成">3、便捷组件生成</h3>
<pre><code class="language-json">{
    &quot;create&quot;: &quot;node build/create-component&quot;,
    &quot;generate&quot;: &quot;node build/create-md&quot;
}
</code></pre>
<p>一键生成新的组件规则，通过读取模板，生成组件主文件，组件样式文件，组件文档，将组件添加进路由等等一系列重复操作，减少开发人员开发成本，也是不可或缺的一部分，通过命令行inquiry式调用，提升开发效率</p>
<h3 id="4-组件命令封装">4、组件命令封装</h3>
<p>文档打包，组件打包，全量、按需、开发、生产，<code>require(&quot;package.json&quot;).script</code>会越来越大，显得十分臃肿且难以理解，封装一个cli，可以增加可读性，减小代码体积，也提升了再建组件库的通用性。</p>
<pre><code class="language-json">&quot;scripts&quot;: {
&quot;bootstrap&quot;: &quot;yarn || npm i&quot;,
&quot;dev&quot;: &quot;vant-cli dev&quot;,
&quot;lint&quot;: &quot;vant-cli lint&quot;,
&quot;test&quot;: &quot;vant-cli test&quot;,
&quot;build&quot;: &quot;vant-cli build&quot;,
&quot;release&quot;: &quot;vant-cli release&quot;,
&quot;test:watch&quot;: &quot;vant-cli test --watch&quot;,
&quot;release:site&quot;: &quot;sh docs/site/release.sh&quot;,
&quot;test:coverage&quot;: &quot;open test/coverage/index.html&quot;
}
</code></pre>
<h1 id="总结">总结</h1>
<p>一个好的组件库不仅在组件本身的通用性，易用性，也在于整体组件库架构设计的可重用性，规范性，易扩展性，市面上的组件库层次不齐，组件库设计可以参考大的如element-ui，ant-design，vant等优秀组件库进行设计</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[md-loader详解]]></title>
        <id>https://chentianyuan.github.io/post/md-loader-xiang-jie/</id>
        <link href="https://chentianyuan.github.io/post/md-loader-xiang-jie/">
        </link>
        <updated>2020-02-14T06:54:48.000Z</updated>
        <summary type="html"><![CDATA[<p>没有你的日子里，我真的好想你<br>
枯了，年前1月20送修的电脑，一个月了才拿回来🤕</p>
]]></summary>
        <content type="html"><![CDATA[<p>没有你的日子里，我真的好想你<br>
枯了，年前1月20送修的电脑，一个月了才拿回来🤕</p>
<!-- more -->
<p>这篇文章加强认知的同时，使用一下star法则，加强表达能力</p>
<h2 id="situation-情景">situation 情景</h2>
<p>公司的组件库出第二版了，技术栈是vue2.6+ts，项目写到快要验收的阶段，问题出现了。组件库的文档在直接使用markdown-loader解析md的情况下，出现了md和demo不对应的情况。（有些开发者（好吧就是我自己。。）组件写完，文档写完，发现还要写.vue的demo组件，在本身还有繁杂业务需求的情况下，开始焦躁不已，demo也就草草了事了），对一些复杂组件，一个不和文档对应的demo，跟没有一样。因此，我们把目光瞄向了文档demo对应的element-ui。</p>
<h2 id="task-任务">task 任务</h2>
<p>任务就是创建出一套md和demo对应的组件文档。</p>
<h2 id="action-执行">action 执行</h2>
<p>确认过眼神，我遇上对的loader。看到element用md作为vue-router的路由组件的时候，element-ui的md-loader应该就是我们想要的东西。<br>
md中使用</p>
<pre><code>::: demo
```html
&lt;action-sheet&gt;...&lt;/actionsheet&gt;
export default { ... }
\```
:::
</code></pre>
<p>包裹的东西最后会转成我们的demo，因此我们只要写一份md就能得到demo和文档了。</p>
<h3 id="md-loader">md-loader</h3>
<p>一个webpack loader说白了其实就是一个接受source的function，函数处理source之后，返回一个新的source交给下个loader处理。</p>
<h3 id="来康康md-loader的处理顺序">来康康md-loader的处理顺序</h3>
<p>1、获取处理好的md<br>
这边分几种情况</p>
<ul>
<li>普通的md语法 交由markdown-it来解析，得到标签包裹好的文本</li>
<li>对于被:::demo所包裹的sfc语法，进行两步操作。
<ul>
<li>将这部分代码用<code>&lt;!--element-demo: :element-demo--&gt;</code>包裹，这个属于一个占位符，在我们遍历demo时便是以这个来标识demo代码的起点和终点的</li>
<li>再使用<code>&lt;demo-block&gt;...&lt;/demo-block&gt;</code>包裹</li>
<li>得到一份新的md</li>
<li>针对新的md，改变markdown对demo块的处理方式，并放入<code>&lt;template slot=&quot;highlight&quot;&gt;</code>中，作为代码展示部分</li>
</ul>
<pre><code>if (token.info === 'html' &amp;&amp; isInDemoContainer) {
  return `&lt;template slot=&quot;highlight&quot;&gt;&lt;pre v-pre&gt;&lt;code class=&quot;html&quot;&gt;${md.utils.escapeHtml(token.content)}&lt;/code&gt;&lt;/pre&gt;&lt;/template&gt;`;
}
</code></pre>
<ul>
<li><code>md.render(source)</code> 得到最后的代码块</li>
</ul>
</li>
</ul>
<p>2、处理代码块，将其变成vue-loader能够处理的模样<br>
其实，如果md中只有一个demo，根本没有必要进行这步处理，将模板直接塞入source，交给vue-loader处理就好了。可是理想很美好，现实很骨感，每个md一般会有多个demo块，如果共用一份状态，必须混合状态，且状态名不能重复，非常不方便，因此md-loader是这样处理的。</p>
<pre><code>const demoComponentName = `element-demo${id}`;
output.push(`&lt;template slot=&quot;source&quot;&gt;&lt;${demoComponentName} /&gt;&lt;/template&gt;`);
</code></pre>
<p>对每个块插入一个<code>element-demo${id}</code>组件，然后这个组件，就是我们接下来要生成的了，确保了每个demo都是独立互不干扰的。最后这些组件会通过插槽的形式，插入demo-block组件提供的槽位中。</p>
<h3 id="生成element-demoid组件的render函数">生成element-demo${id}组件的render函数</h3>
<p>依赖的两个库分别是<code>@vue/component-compiler-utils</code>和<code>vue-template-compiler</code>，</p>
<ul>
<li><code>let demoComponentContent = genInlineComponentText(html, script);</code> 通过genInlineComponentText函数生成我们所需的组件代码</li>
<li>将合法的options传给<code>@vue/component-compiler-utils</code>中提供的<code>compileTemplate</code>函数</li>
</ul>
<pre><code class="language-javascript">  const finalOptions = {
    source: `&lt;div&gt;${template}&lt;/div&gt;`,
    filename: 'inline-component', // TODO：这里有待调整
    compiler
  };
  const compiled = compileTemplate(finalOptions);
  let demoComponentContent = `
    ${compiled.code}
  `;
  demoComponentContent = `(function() {
    ${demoComponentContent}
    ${script}
    return Object.assign({
      render,
      staticRenderFns
    }, democomponentExport)
  })()`;
  return demoComponentContent;
</code></pre>
<ul>
<li>最后的demoComponentContent就是我们要的script了~<br>
举个例子，最后的demoComponentContent的样子类似这样</li>
</ul>
<pre><code class="language-javascript">&quot;element-demo0&quot;: (function () {
    var render = function (_c) { return _c(....) }
    var staticRenderFns = []
    const democomponentExport = {
        data () {
            return {
            value1: false,
            actions1: [
                { value: 1, label: '项目1' }, 
                { value: 2, label: '项目2' }, 
                { value: 3, label: '项目3' }
            ]
            }
        },
        ...options
    }
    return Object.assign({
        render,
        staticRenderFns
    }, democomponentExport)
})
</code></pre>
<h2 id="result-结果">result 结果</h2>
<p>将生成的模板，和得到的element-demo${id}组件script一起，插入到新的模板中</p>
<pre><code class="language-javascript">// md-loader
  return `
    &lt;template&gt;
      &lt;section class=&quot;content wand-doc&quot; :class=&quot;'wand-doc-' + $route.fullPath.substring(1)&quot;&gt;
        ${output.join('')}
      &lt;/section&gt;
    &lt;/template&gt;
    ${pageScript}
  `;
</code></pre>
<p>下一步便由vue-loader处理了，生成整个路由组件的render函数并在路由访问时执行并挂载到页面上！最后我们看到的文档和demo就是一一对应的了，看起来非常得直观。<br>
<img src="https://chentianyuan.github.io/post-images/1581670429040.png" alt="" loading="lazy"><br>
完成！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js垃圾回收机制]]></title>
        <id>https://chentianyuan.github.io/post/js-la-ji-hui-shou-ji-zhi/</id>
        <link href="https://chentianyuan.github.io/post/js-la-ji-hui-shou-ji-zhi/">
        </link>
        <updated>2020-01-16T03:55:24.000Z</updated>
        <summary type="html"><![CDATA[<p>每种语言都有垃圾回收机制，来回收不再使用的内存空间，垃圾回收又分为主动回收和被动回收两种...</p>
]]></summary>
        <content type="html"><![CDATA[<p>每种语言都有垃圾回收机制，来回收不再使用的内存空间，垃圾回收又分为主动回收和被动回收两种...</p>
<!-- more -->
<p>在js，python，java中使用的都是自动垃圾回收机制，开发者无需主动清除变量所占用的内存，但是在某些场景下，关注内存情况还是很必要的。</p>
<p>js中的变量都存储在栈和堆中，二者回收机制也不同。</p>
<h2 id="栈内存回收">栈内存回收</h2>
<p>js代码会放到一个执行栈中运行，每碰到一个运行函数的指令，就为当前函数创建执行上下文，然后推入调用栈，当函数执行完毕，则函数出栈，开始执行下一个任务。<br>
js内部会有一个ESP(记录当前执行状态的指针)，该指针总是指向当前的执行上下文，当函数执行完毕ESP指针下移之后，还会销毁ESP上一个指向的函数保存在栈中的执行上下文，从而自动回收其中保存在栈中基本类类型的内存。</p>
<h2 id="堆内存回收">堆内存回收</h2>
<p><strong>基本类型存在栈中的内存会随着执行上下文被销毁而自动回收</strong>，而堆内存需要额外的机制来进行回收。</p>
<h3 id="代际假说the-generational-hypothesis">代际假说(The Generational Hypothesis)</h3>
<ul>
<li>大部分对象在内存中存活的时间很短，很多对象占用的内存一经分配就变得不可访问 (新生代)</li>
<li>不死的对象会活得更久 (老生代)<br>
为了对这两种情况下的垃圾进行回收，在V8中会把堆内存分为新生代和老生代两个区域。<br>
新生代的容量较小，老生代容量大。然后针对这两种区域分别使用<code>副回收器(新生代)</code>和<code>主回收器(老生代)</code>对垃圾进行回收。</li>
</ul>
<h3 id="副垃圾回收器">副垃圾回收器</h3>
<p><img src="https://chentianyuan.github.io/post-images/1579243473477.png" alt="新生代和老生代" loading="lazy"><br>
副垃圾回收器使用的是一种Scavenge算法来处理垃圾的，新生代会被对半划分为对象区域和空闲区域，新加入的对象会加入对象区域，当对象区域快被写满的时候就会开始垃圾回收。</p>
<ul>
<li>标记对象区域还在使用的对象</li>
<li>将被标记的对象复制到空闲区域</li>
<li>对复制后的对象做内存整理操作，合并内存间隙</li>
<li>角色翻转，将对象区域转为空闲区域，对空闲区域转为对象区域，上一次未被标记的对象占用的内存则被垃圾回收<br>
如果新生代内存设置得过大，那么每次清理时间就会过久，造成程序运行缓慢，所以为了执行效率，一般新生代的空间会设的比较小，js中一般是1~8M。新生代的内存区域不大如果都放在新生代则容易被存活对象占满整个区域，所以js引擎采用了<code>对象晋升策略</code>，进过两次垃圾回收依然存活的对象，会被移动到老生代中。另外除了从新生区晋升的对象外，一些比较大的对象会直接被分配到老生代。</li>
</ul>
<h3 id="主垃圾回收器">主垃圾回收器</h3>
<p>主垃圾回收器负责回收老生代区域的垃圾对象，它有内存大，存活时间长等特点，如果继续采用Scavenge算法，拷贝大内存对象十分耗时，导致垃圾回收执行效率不高。因此，主垃圾回收器采用的是<code>标记清除</code>垃圾回收算法。<br>
<img src="https://chentianyuan.github.io/post-images/1579244309852.png" alt="主垃圾回收器" loading="lazy"><br>
主垃圾回收器会定期遍历当前的调用栈，然后对当前老生代中的对象使用情况进行标记，如果在调用栈发现了对对象的引用则标记为活动对象，否则标记为垃圾数据。<br>
当对老生代的垃圾回收之后进行<code>标记整理</code>使所有对象向一端移动清除内存间隙。</p>
<h3 id="增量标记算法只针对老生代才有标记清除算法">增量标记算法（只针对老生代才有标记清除算法）</h3>
<p>由于如果js运行的主线程是单线程作业，如果垃圾积攒过多，比如1.5G的老生代需要大约1s的时间进行回收，那么js运行会被垃圾回收阻塞，页面就会有明显的卡顿。因此，为了避免垃圾回收对程序运行带来的影响，V8将标记过程分为一个个的子标记过程，垃圾回收标记和js应用逻辑交替运行，这种算法叫增量标记算法，将一个完整的垃圾回收任务分为很多个小任务，用户就不会因为垃圾回收的阻塞而感到卡顿了。(但是其实这也是在刷题的时候感觉js运行效率不高的原因吧= =，在逻辑运算过程中还穿插了垃圾回收，向java这种多线程语言垃圾回收应该是单独一个线程吧猜想(¦3[▓▓] )。</p>
<h3 id="总结">总结</h3>
<p>懒一下，之后总结。。。😹😹😹</p>
<h2 id="资料参考">资料参考</h2>
<p><a href="https://time.geekbang.org/column/article/131233">极客时间浏览器工作原理与实践（李兵）</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue生命周期（简略版）]]></title>
        <id>https://chentianyuan.github.io/post/vue-sheng-ming-zhou-qi/</id>
        <link href="https://chentianyuan.github.io/post/vue-sheng-ming-zhou-qi/">
        </link>
        <updated>2020-01-11T05:42:15.000Z</updated>
        <summary type="html"><![CDATA[<p>通过 debugger vue 源码 观察得出的vue生命周期流程<br>
对vue的生命周期进行深入了解 (*/ω＼*)</p>
]]></summary>
        <content type="html"><![CDATA[<p>通过 debugger vue 源码 观察得出的vue生命周期流程<br>
对vue的生命周期进行深入了解 (*/ω＼*)</p>
<!-- more -->
<blockquote>
<p>版本：vue2.6.11 完整版本</p>
</blockquote>
<p>附官方配图<br>
<img src="file:///Users/apple/Documents/Gridea/post-images/1578721758426.png" style="zoom:50%" /></p>
<p>一切的一切要从vue文件加载说起</p>
<h2 id="init">init</h2>
<p>无论是模块化引入，还是script标签加载，都会引入vue的bundle文件，在进入生命周期之前，vue会执行如下几个方法<br>
往vue的构造函数上挂载之后需要用到的变量，往原型上挂载要用到的方法<br>
修改push，pop等数组操作方法，使用包装器包装</p>
<pre><code class="language-javascript">// initGlobalAPI
initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
</code></pre>
<h2 id="new-vueoptions">new Vue(options)</h2>
<p>新建vue实例的时候，构造函数内只有一个入口<code>this._init(options);</code></p>
<h2 id="mergeoptionsconstructoroptions-options-vm">mergeOptions(constructor.options, options, vm)</h2>
<p>将initGlobalApi中初始化的构造函数上的属性和传入的属性做一次merge，此时，一些我们平常没有注入的Component，keep-alive，transition，transition-group三个内置组件也是在这里被merge进我们的option的。值得一提的是，这里的merge不是简单的对象合并，针对不同的option，会采用不同的合并策略，比如data执行后合并成新的data函数，生命周期钩子，则被推入对应生命周期数组中</p>
<h2 id="beforecreate">beforeCreate</h2>
<pre><code class="language-javascript">initLifecycle(vm);
initEvents(vm);
initRender(vm);
callHook(vm, 'beforeCreate');
</code></pre>
<p>执行beforeCreate钩子，此时的数据还不是响应式，真实dom也没有挂载到页面，页面还是带vue语法的模板</p>
<h2 id="数据监测">数据监测</h2>
<p>从data函数开始，<code>data.call(vm, vm)</code>得到data对象，对data对象的每个属性进行监测，为每个属性新建一个dep对象<code>const dep = new Dep()</code>，通过<code>Obejct.defineProperty</code>设置对应属性的get，set，在get中进行依赖收集，需要收集的地方会将Dep.target加到dep.sub中<code>dep.addSub(Dep.target)</code>，在被set时，通过<code>dep.notify() =&gt; watcher.cb()</code>来通知模板更新，如果属性是数组，其数组操作方法在初始化时已经被替换，则在各个操作方法中进行通知。如果当前key对应的属性仍不是基本类型，则继续进行深度遍历，知道所有属性被监听。除了data这一阶段还包括对watcher和computed的处理。</p>
<h2 id="create">Create</h2>
<p>这一阶段还包括了父组件provide和子组件inject的初始化处理，数据监听完毕，触发create钩子</p>
<pre><code class="language-javascript">initInjections(vm); // resolve injections before data/props
initState(vm);
initProvide(vm); // resolve provide after data/props
callHook(vm, 'created');
</code></pre>
<h2 id="模板编译阶段-compiletofn">模板编译阶段 CompileToFn</h2>
<p>vue分两种版本，一种是包含模板编译大一点的版本，一种是vue.runtime.js，只包含运行时的版本，在使用webpack构建时常使用vue-loader来预处理模板，因此到页面上只需引入运行时的vue版本就好了，而没有使用模板编译的话，只能引入全量的vue了。所谓模板编译，其实就是template到render函数的过程，中间通过ast转化，通过正则匹配来确定是普通的html语法还是vue的特殊语法从而进行不同的特殊处理，最后得到一个类似这样的render函数</p>
<pre><code class="language-javascript">(function anonymous(
) {
with(this){return _c('div',{attrs:{&quot;id&quot;:&quot;demo&quot;}},[_c('h1',[_v(&quot;Latest Vue.js Commits&quot;)]),_v(&quot; &quot;),_l((branches),function(branch){return [_c('input',{directives:[{name:&quot;model&quot;,rawName:&quot;v-model&quot;,value:(currentBranch),expression:&quot;currentBranch&quot;}],attrs:{&quot;type&quot;:&quot;radio&quot;,&quot;id&quot;:branch,&quot;name&quot;:&quot;branch&quot;},domProps:{&quot;value&quot;:branch,&quot;checked&quot;:_q(currentBranch,branch)},on:{&quot;change&quot;:function($event){currentBranch=branch}}}),_v(&quot; &quot;),_c('label',{attrs:{&quot;for&quot;:branch}},[_v(_s(branch))])]}),_v(&quot; &quot;),_c('p',[_v(&quot;vuejs/vue@&quot;+_s(currentBranch))]),_v(&quot; &quot;),_c('ul',_l((commits),function(record){return _c('li',[_c('a',{staticClass:&quot;commit&quot;,attrs:{&quot;href&quot;:record.html_url,&quot;target&quot;:&quot;_blank&quot;}},[_v(_s(record.sha.slice(0, 7)))]),_v(&quot;\n          - &quot;),_c('span',{staticClass:&quot;message&quot;},[_v(_s(_f(&quot;truncate&quot;)(record.commit.message)))]),_c('br'),_v(&quot;\n          by &quot;),_c('span',{staticClass:&quot;author&quot;},[_c('a',{attrs:{&quot;href&quot;:record.author.html_url,&quot;target&quot;:&quot;_blank&quot;}},[_v(_s(record.commit.author.name))])]),_v(&quot;\n          at &quot;),_c('span',{staticClass:&quot;date&quot;},[_v(_s(_f(&quot;formatDate&quot;)(record.commit.author.date)))])])}),0)],2)}
})
</code></pre>
<p>with语法执行了当前作用域环境，_c其实就是常见的createElement函数</p>
<h2 id="模板编译完成得到render函数触发beforemounted钩子">模板编译完成，得到render函数，触发beforeMounted钩子</h2>
<h2 id="vnodetoelmmounted钩子触发">vnodeToElm，mounted钩子触发</h2>
<p>函数执行生成的是vnode，再经由<code>vm._update(vnode, hydrating)</code>处理，进入<code>vm.__patch__(vm.$el, vnode, hydrating, false)</code>处理，第一次不会进入<code>patchVnode</code>函数，进入生成分支<code>emptyNodeAt(elm)</code>，生成最外层的父节点，再执行<code>createElm</code>阶段，将当前elm设置成<code>document.createElement(tagName)</code>，再继续进行<code>createChildren</code>，对节点的子节点重复调用<code>createElm</code>，所得的真实dom会通过parent.insertBefore或者parent.appendChild添加到父级真实dom中，最后再移除之前所有的未编译节点，呈现最终的页面（vnode.elm可以看到所有的真实节点）<br>
<code>mountComponent</code>执行完毕，触发mounted钩子，页面上已有真实dom，但是尚未渲染。</p>
<h2 id="nexttick异步任务">nextTick异步任务</h2>
<p><img src="https://chentianyuan.github.io/post-images/1578730088518.png" alt="渲染流程" loading="lazy"><br>
根据浏览器兼容性，promise =&gt; mutationObserver =&gt; setTimeout<br>
微任务可以确保执行时间点会在会在渲染完毕之前，所以在promise =&gt; mutationObserver实现的情况下只会进行一次渲染，而setTimeout(fn, 0)，无法确保执行时间是在渲染后还是渲染之前，所以可能会造成重复渲染，造成跳帧的感觉。</p>
<h2 id="beforeupdate钩子">beforeUpdate钩子</h2>
<p>在mounted之后，data数据发生改变时调用，其有一个专属的组件级的watcher，在数据变化时会被调用before函数，在所有设置的watcher之前，触发beforeUpdate钩子。</p>
<h2 id="updated钩子">updated钩子</h2>
<p>在beforeUpdate钩子之后，对所有的update钩子进行执行<code>nextTick(flushSchedulerQueue) -&gt; callHook(vm, 'update')</code>，如果设置了，则每次在下一次重渲染之前，update钩子会被调用。</p>
<h2 id="beforedestory钩子">beforeDestory钩子</h2>
<p>destory可以通过<code>vm.$destory()</code>来主动触发，其并不会影响页面的展示，但是会清理与其它实例的连接，解绑(<code>vm.deps[i].removeSub()</code>)当前实例的全部指令及事件监听器，然后执行<code>vm.__patch__(vm._vnode, null)</code>，将当前vnode置空，并在其中会触发子组件的destory方法，和mounted一样，destory钩子也是先子组件后父组件</p>
<h2 id="destory钩子">Destory钩子</h2>
<p>所有销毁动作完成之后，触发destroyed钩子，</p>
<h2 id="activated钩子-deactivated钩子">activated钩子 &amp;&amp; deactivated钩子</h2>
<p>涉及keep-alive没有深入研究，大概是组件被复用和缓存组件被销毁时触发</p>
<hr>
<h2 id="总结">总结</h2>
<p>1、js加载并执行，混入必要的属性和方法，声明常用工具类方法<br>
2、实例化，属性合并，初始化解析event事件绑定的方法<br>
3、触发beforeCreate<br>
4、进行数据监测，依赖收集<br>
5、触发craete<br>
6、进行模板编译，将模板转化为render函数<br>
7、触发beforeMounted<br>
8、执行render函数，生成vnode，根据vnode创建真实dom，挂载到指定节点<br>
9、触发mounted钩子<br>
<strong>其他</strong><br>
10、beforeUpdate执行所在的函数在beforeMounted和mounted之前已经生成了，mounted之后的数据变动都会触发beforeUpdate<br>
11、watcher.run()<br>
12、模板更新结束，触发updated钩子<br>
13、beforeDestory组件销毁时触发，也可主动触发，进行事件解绑，依赖移除，vnode清空，执行顺序是先子组件后父组件<br>
14、destory组件销毁完毕触发<br>
15、activated钩子 &amp;&amp; deactivated钩子 缓存组件复用和缓存组件被销毁时触发</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生命关怀的呼唤]]></title>
        <id>https://chentianyuan.github.io/post/sheng-ming-guan-huai-de-hu-huan/</id>
        <link href="https://chentianyuan.github.io/post/sheng-ming-guan-huai-de-hu-huan/">
        </link>
        <updated>2019-12-22T11:49:39.000Z</updated>
        <summary type="html"><![CDATA[<p>在死亡到来的那一天，人人平等，离开这个熟悉又陌生的世界前，我们能带给她们什么？</p>
]]></summary>
        <content type="html"><![CDATA[<p>在死亡到来的那一天，人人平等，离开这个熟悉又陌生的世界前，我们能带给她们什么？</p>
<!-- more -->
<p>上海临终关怀医院，那里住着的多是不治之症的患者，还有一些因为忍受不了病痛的折磨，放弃治疗，平静等待死亡的重病病人。</p>
<p>情况好一些的病人，如果走出医院，她们看起来和常人没什么区别，但是每每发病的夜晚，晚期疾病带来的痛苦和煎熬，只有她们自己知道。</p>
<p>还有些病人，没法说话，无法进食，没法闭上眼睛，没法睡觉，肺部感染带来的高烧在一步一步地销蚀她们的身体，每一次喘气都好像耗尽了她们的所有力气。病房的时钟滴答滴答地走着，像是死神的计时表，不知道哪一秒，死神就挥下了它的镰刀。</p>
<figure data-type="image" tabindex="1"><img src="https://chentianyuan.github.io/post-images/1577017544790.png" alt="death" loading="lazy"></figure>
<p><s>如果时间能够倒转，也许不会是现在的光景。</s></p>
<p>当她失去自主意识，只是本能地呼吸，死亡倒成了一种奢望。</p>
<p>在现代医学已经无能为力的时候，面对这些即将离开的人，我们还能为她们做些什么？</p>
<p>有时候，什么也做不了，做什么，都是徒劳。</p>
<p>关怀生命，不是生命结束前的一个口号，而是生者的呼唤，一种生活的态度，一种不让那一天到来留下遗憾的祈盼。</p>
<p>太负能量了，再也不写这种了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深度优先遍历和广度优先遍历]]></title>
        <id>https://chentianyuan.github.io/post/shen-du-you-xian-bian-li-he-guang-du-you-xian-bian-li/</id>
        <link href="https://chentianyuan.github.io/post/shen-du-you-xian-bian-li-he-guang-du-you-xian-bian-li/">
        </link>
        <updated>2019-12-04T13:17:43.000Z</updated>
        <summary type="html"><![CDATA[<p>DFS VS BFS</p>
]]></summary>
        <content type="html"><![CDATA[<p>DFS VS BFS</p>
<!-- more -->
<h3 id="题目">题目</h3>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<pre><code class="language-javascript">// DFS 解题
var rightSideView = function(root) {
    let resultList = []
    let i = 0
    let dfs = function (Node, i) {
      // 该节点不存在
      if (!Node) {
        return
      }
      resultList[i] = resultList[i] || []
      resultList[i].push(Node.val)
      dfs(Node.left, i + 1)
      dfs(Node.right, i + 1)
    }
    dfs(root, i)
    return resultList.map(result =&gt; result[result.length - 1])
};
// 优先左子树，再遍历右子树，每次递归深度+1
</code></pre>
<pre><code class="language-javascript">// BFS 解题
var rightSideView = function(root) {
    let resultList = []
    let j = -1
    let bfs = function (Nodes) {
      while (Nodes.length &gt; 0) {
        j++
        // 该节点不存在
        if (!Nodes.length) {
          return
        }
        let length = Nodes.length
        for (let i = 0; i &lt; length; i++) {
          let Node = Nodes.shift()
          resultList[j] = resultList[j] || []
          resultList[j].push(Node.val)
          if (Node.left) Nodes.push(Node.left)
          if (Node.right) Nodes.push(Node.right)
        }
      }
    }
    if (!root) return []
    bfs([root])
    return resultList.map(result =&gt; result[result.length - 1])
};
// 广度优先遍历的核心就是queues
// 队列存储左右节点，然后进入下一次循环，循环原始队列，队列头出队列，将左子树右子树分别重新插入队列，最后的到的类似[left.left, left.right, right.left, right.right]进行我们想要的操作
</code></pre>
<p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">力扣原题</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器工作原理及实践]]></title>
        <id>https://chentianyuan.github.io/post/liu-lan-qi-gong-zuo-yuan-li-ji-shi-jian/</id>
        <link href="https://chentianyuan.github.io/post/liu-lan-qi-gong-zuo-yuan-li-ji-shi-jian/">
        </link>
        <updated>2019-11-08T10:51:13.000Z</updated>
        <summary type="html"><![CDATA[<p>极客时间课程笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>极客时间课程笔记</p>
<!-- more -->
<h2 id="0-chrome架构">0、chrome架构</h2>
<p>q: 为什么chrome打开一个页面，会启动四个进程？<br>
a: 浏览器主进程、插件进程、网络进程、渲染进程、GPU进程(GPU进程用于3D绘制，在2d场景下渲染进程就可以)存在进程隔离，相比在ie6中使用单进程架构，任意一个进程崩溃都会导致浏览器的崩溃，chrome的多进程架构很好的解决了这个问题。而且每个进程都在沙箱中运行，也解决了插件的安全问题。</p>
<h2 id="1-tcp协议">1、TCP协议</h2>
<p>q: TCP协议为什么能完整地传输页面？<br>
a: 首先，了解一下过程，TCP和UDP都作为传输层的协议，TCP和UDP都需要在传输层向数据包中添加端口，然后网络层的ip协议添加ip端口。UDP为无连接的传输协议，无法组装数据包，而且容易丢包，常用于视频传输，或者音频传输。而TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，相对于UDP，有丢包重传和数据包排序（数据包按顺序组装成完整文件）的特点。</p>
<h2 id="2-http请求流程">2、http请求流程</h2>
<figure data-type="image" tabindex="1"><img src="https://chentianyuan.github.io/post-images/1573212377705.png" alt="部分流程" loading="lazy"></figure>
<h2 id="3-从输入一个url到显示页面发生了什么">3、从输入一个url到显示页面发生了什么？</h2>
<p>（以前总是想把每个细节都说的很完整，但是在面试中，这个的关键是流程，不是细节流程，大可等面试官下一个问题）</p>
<ol>
<li>用户输入url，按下回车键</li>
<li>浏览器检查url，组装协议</li>
<li>浏览器进程通过ipc通知网络进程</li>
<li>网络进程接收到url后检查本地缓存，是则直接拿出缓存给浏览器进程，否则<br>
4.1 dns解析，拿到ip和端口（80或443）<br>
4.2 通过TLS协议，建立安全连接<br>
4.3 建立TCP连接<br>
4.4 TCP、IP协议组装数据包，发送请求<br>
4.4 网络进程接收响应信息，并解析响应内容 （略去了304的流程）</li>
<li>网络进程通知浏览器进程，浏览器进程决定是否需要重新开启渲染进程</li>
<li>浏览器进程通知渲染进程，渲染进程和网络进程建立管道，开始接收数据</li>
<li>加载css，解析html，生成cssom和domTree，进而生成render tree，如遇到js则阻塞渲染和解析，js的加载不一定阻塞，最后js执行完毕，进行layout，最后进行paint</li>
<li>渲染进程通知，浏览器进程更新状态，icon、前进后退状态、安全等</li>
</ol>
<h2 id="4-渲染进程">4、渲染进程</h2>
<p>浏览器无法直接渲染html文件，需要经历以下步骤<br>
dom tree =&gt; document<br>
cssom =&gt; document.stylesheet<br>
合并得到layoutTree <strong>（布局树）</strong><br>
得到布局树之后，还不能直接绘制，浏览器的页面实际上被分为了很多图层**（元素有了层叠上下文属性或者需要裁剪都会形成新的图层）**，所有图层叠加得到了最后的页面<br>
渲染进程绘制图层<br>
GPU进程进行栅格化操作，为视口区域生成位图，保存在GPU内存中<br>
最后通知浏览器进程，展示页面</p>
<h2 id="5-浏览器内的js执行">5、浏览器内的js执行</h2>
<p>全局代码执行首先会编译代码，然后创建执行上下文和将代码分别在变量环境和词法环境执行<br>
在碰到function执行时会创建新的上下文和新的词法环境<br>
同eval执行wei'd'wa<br>
<img src="https://chentianyuan.github.io/post-images/1573476515573.png" alt="执行上下文" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https协议详解]]></title>
        <id>https://chentianyuan.github.io/post/https-xie-yi-xiang-jie/</id>
        <link href="https://chentianyuan.github.io/post/https-xie-yi-xiang-jie/">
        </link>
        <updated>2019-10-30T12:11:46.000Z</updated>
        <summary type="html"><![CDATA[<p>最后一次，理解https协议</p>
]]></summary>
        <content type="html"><![CDATA[<p>最后一次，理解https协议</p>
<!-- more -->
<h3 id="why">why？</h3>
<p>首先要明确的是https是为了解决什么问题<br>
http请求的所有数据都是明文传输，在网络中无异于裸奔，会出现以下几个问题</p>
<ol>
<li>数据窃听</li>
<li>假装真实客户端向恶意攻击服务端</li>
<li>假装服务端返回假数据<br>
https在应用层和传输层中间增加了SSL层，SSL可以理解为CA证书的作用（防止中间人篡改）<br>
然后使用TLS协议通信，生成对称密匙后采用对称加密，（防止中间人窃取）保证了数据的安全性</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://chentianyuan.github.io/post-images/1572438323964.JPG" alt="Jesus" loading="lazy"></figure>
<h3 id="how">how？</h3>
<p>流程详解</p>
<ol>
<li>TCP链接建立之后</li>
<li>客户端向服务端443端口发起请求，携带random1和加密方法列表，TLS第一步</li>
<li>服务端返回CA证书携带服务端公匙和random2</li>
<li>客户端拿到CA证书和公匙，和本地CA证书对比校验证书有效性（这里防止中间人篡改随机数）</li>
<li>验证有效后，客户端生成random3，这里做了两件事，第一自己使用random1，random2，random3生成对称密匙sercet，第二使用服务端给出的公匙加密random3，返回给服务端（非对称加密防止中间人窃取）</li>
<li>服务端拿到加密后的random3，使用私匙解密，截止目前为止，客户端和服务端都知道random1，random2，random3，服务端也生成对称密匙sercet，得到双方都知道的对称密匙</li>
<li>最后，双方使用对称密匙加密数据进行通信</li>
</ol>
<p>总结：<br>
利用CA证书，加密先使用非对称加解密，再使用对称密匙加解密，解决了http带来的窃听和请求伪造的问题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[commonjs和ES6模块的区别]]></title>
        <id>https://chentianyuan.github.io/post/commonjs-he-es6-mo-kuai-de-qu-bie/</id>
        <link href="https://chentianyuan.github.io/post/commonjs-he-es6-mo-kuai-de-qu-bie/">
        </link>
        <updated>2019-10-26T03:10:51.000Z</updated>
        <summary type="html"><![CDATA[<p>对比commonjs和ES6，了解前端模块化机制</p>
]]></summary>
        <content type="html"><![CDATA[<p>对比commonjs和ES6，了解前端模块化机制</p>
<!-- more -->
<h2 id="commonjs-规范">commonjs 规范</h2>
<p>1、commonjs应用于nodejs模块化管理，是nodejs实现的一套模块化机制。</p>
<p>2、commonjs属于动态编译，运行时才确定加载模块，输入时需查找对象属性，所以无法做到按需加载，总是引入整个模块对象。</p>
<p>3、模块导出的是值得拷贝各个引用互不影响。</p>
<p>4、this指向当前模块。</p>
<h2 id="es6-module">ES6 module</h2>
<p>1、es6的模块化可以应用在浏览器和node服务端。</p>
<p>2、es6模块的设计思想，是尽量静态化，在编译时就确定模块的依赖关系以及输入和输出的变量，其静态编译使得可以编译时就确认要使用的模块中的内容可做按需加载。</p>
<p>3、模块导出的是值得引用，若其中引用被修改，下次引用时得到的是修改后的值。</p>
<p>4、this指向undefined。</p>
<pre><code class="language-javascript">import zw from './a' 
import('./b').then(res =&gt; {
  console.log(zw) // b模块修改后的zw的值
})
</code></pre>
<h2 id="扩展">扩展</h2>
<p>webpack打包时默认会模拟一套类commonjs规范的加载器，如果有使用spliteChunk抽离出runtime的话，可以查阅相关代码，所以webpack默认是无法做到按需加载的，像<code>import { Button } from 'Antd'</code>这样的语句会打包Antd提供的所有模块，并使用其中的babel模块，我们可以引入<code>babel-plugin-component</code>或者<code>babel-plugin-import</code>来解决这个问题。</p>
<blockquote>
<p>babel 能提前将 es6 的 import 等模块关键字转换成 commonjs 的规范。这样 webpack 就无需再做处理，直接使用 webpack 运行时定义的 <strong>webpack_require</strong> 处理。而babel-plugin-component就做了一件事，将 import { Button } from 'antd' 转换成了 import Button from 'antd/lib/button'，这样即便转成commonjs规范也只引入了一个库文件</p>
</blockquote>
<p>深夜打卡<br>
<s>水了一篇，开心٩(๑❛ᴗ❛๑)۶</s></p>
]]></content>
    </entry>
</feed>